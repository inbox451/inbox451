// Code generated by mockery. DO NOT EDIT.

package mocks

import (
	context "context"
	models "inbox451/internal/models"

	mock "github.com/stretchr/testify/mock"
)

// Repository is an autogenerated mock type for the Repository type
type Repository struct {
	mock.Mock
}

type Repository_Expecter struct {
	mock *mock.Mock
}

func (_m *Repository) EXPECT() *Repository_Expecter {
	return &Repository_Expecter{mock: &_m.Mock}
}

// CreateInbox provides a mock function with given fields: ctx, inbox
func (_m *Repository) CreateInbox(ctx context.Context, inbox *models.Inbox) error {
	ret := _m.Called(ctx, inbox)

	if len(ret) == 0 {
		panic("no return value specified for CreateInbox")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *models.Inbox) error); ok {
		r0 = rf(ctx, inbox)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Repository_CreateInbox_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateInbox'
type Repository_CreateInbox_Call struct {
	*mock.Call
}

// CreateInbox is a helper method to define mock.On call
//   - ctx context.Context
//   - inbox *models.Inbox
func (_e *Repository_Expecter) CreateInbox(ctx interface{}, inbox interface{}) *Repository_CreateInbox_Call {
	return &Repository_CreateInbox_Call{Call: _e.mock.On("CreateInbox", ctx, inbox)}
}

func (_c *Repository_CreateInbox_Call) Run(run func(ctx context.Context, inbox *models.Inbox)) *Repository_CreateInbox_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*models.Inbox))
	})
	return _c
}

func (_c *Repository_CreateInbox_Call) Return(_a0 error) *Repository_CreateInbox_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Repository_CreateInbox_Call) RunAndReturn(run func(context.Context, *models.Inbox) error) *Repository_CreateInbox_Call {
	_c.Call.Return(run)
	return _c
}

// CreateMessage provides a mock function with given fields: ctx, message
func (_m *Repository) CreateMessage(ctx context.Context, message *models.Message) error {
	ret := _m.Called(ctx, message)

	if len(ret) == 0 {
		panic("no return value specified for CreateMessage")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *models.Message) error); ok {
		r0 = rf(ctx, message)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Repository_CreateMessage_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateMessage'
type Repository_CreateMessage_Call struct {
	*mock.Call
}

// CreateMessage is a helper method to define mock.On call
//   - ctx context.Context
//   - message *models.Message
func (_e *Repository_Expecter) CreateMessage(ctx interface{}, message interface{}) *Repository_CreateMessage_Call {
	return &Repository_CreateMessage_Call{Call: _e.mock.On("CreateMessage", ctx, message)}
}

func (_c *Repository_CreateMessage_Call) Run(run func(ctx context.Context, message *models.Message)) *Repository_CreateMessage_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*models.Message))
	})
	return _c
}

func (_c *Repository_CreateMessage_Call) Return(_a0 error) *Repository_CreateMessage_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Repository_CreateMessage_Call) RunAndReturn(run func(context.Context, *models.Message) error) *Repository_CreateMessage_Call {
	_c.Call.Return(run)
	return _c
}

// CreateProject provides a mock function with given fields: ctx, project
func (_m *Repository) CreateProject(ctx context.Context, project *models.Project) error {
	ret := _m.Called(ctx, project)

	if len(ret) == 0 {
		panic("no return value specified for CreateProject")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *models.Project) error); ok {
		r0 = rf(ctx, project)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Repository_CreateProject_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateProject'
type Repository_CreateProject_Call struct {
	*mock.Call
}

// CreateProject is a helper method to define mock.On call
//   - ctx context.Context
//   - project *models.Project
func (_e *Repository_Expecter) CreateProject(ctx interface{}, project interface{}) *Repository_CreateProject_Call {
	return &Repository_CreateProject_Call{Call: _e.mock.On("CreateProject", ctx, project)}
}

func (_c *Repository_CreateProject_Call) Run(run func(ctx context.Context, project *models.Project)) *Repository_CreateProject_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*models.Project))
	})
	return _c
}

func (_c *Repository_CreateProject_Call) Return(_a0 error) *Repository_CreateProject_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Repository_CreateProject_Call) RunAndReturn(run func(context.Context, *models.Project) error) *Repository_CreateProject_Call {
	_c.Call.Return(run)
	return _c
}

// CreateRule provides a mock function with given fields: ctx, rule
func (_m *Repository) CreateRule(ctx context.Context, rule *models.ForwardRule) error {
	ret := _m.Called(ctx, rule)

	if len(ret) == 0 {
		panic("no return value specified for CreateRule")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *models.ForwardRule) error); ok {
		r0 = rf(ctx, rule)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Repository_CreateRule_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateRule'
type Repository_CreateRule_Call struct {
	*mock.Call
}

// CreateRule is a helper method to define mock.On call
//   - ctx context.Context
//   - rule *models.ForwardRule
func (_e *Repository_Expecter) CreateRule(ctx interface{}, rule interface{}) *Repository_CreateRule_Call {
	return &Repository_CreateRule_Call{Call: _e.mock.On("CreateRule", ctx, rule)}
}

func (_c *Repository_CreateRule_Call) Run(run func(ctx context.Context, rule *models.ForwardRule)) *Repository_CreateRule_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*models.ForwardRule))
	})
	return _c
}

func (_c *Repository_CreateRule_Call) Return(_a0 error) *Repository_CreateRule_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Repository_CreateRule_Call) RunAndReturn(run func(context.Context, *models.ForwardRule) error) *Repository_CreateRule_Call {
	_c.Call.Return(run)
	return _c
}

// CreateToken provides a mock function with given fields: ctx, token
func (_m *Repository) CreateToken(ctx context.Context, token *models.Token) error {
	ret := _m.Called(ctx, token)

	if len(ret) == 0 {
		panic("no return value specified for CreateToken")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *models.Token) error); ok {
		r0 = rf(ctx, token)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Repository_CreateToken_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateToken'
type Repository_CreateToken_Call struct {
	*mock.Call
}

// CreateToken is a helper method to define mock.On call
//   - ctx context.Context
//   - token *models.Token
func (_e *Repository_Expecter) CreateToken(ctx interface{}, token interface{}) *Repository_CreateToken_Call {
	return &Repository_CreateToken_Call{Call: _e.mock.On("CreateToken", ctx, token)}
}

func (_c *Repository_CreateToken_Call) Run(run func(ctx context.Context, token *models.Token)) *Repository_CreateToken_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*models.Token))
	})
	return _c
}

func (_c *Repository_CreateToken_Call) Return(_a0 error) *Repository_CreateToken_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Repository_CreateToken_Call) RunAndReturn(run func(context.Context, *models.Token) error) *Repository_CreateToken_Call {
	_c.Call.Return(run)
	return _c
}

// CreateUser provides a mock function with given fields: ctx, user
func (_m *Repository) CreateUser(ctx context.Context, user *models.User) error {
	ret := _m.Called(ctx, user)

	if len(ret) == 0 {
		panic("no return value specified for CreateUser")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *models.User) error); ok {
		r0 = rf(ctx, user)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Repository_CreateUser_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateUser'
type Repository_CreateUser_Call struct {
	*mock.Call
}

// CreateUser is a helper method to define mock.On call
//   - ctx context.Context
//   - user *models.User
func (_e *Repository_Expecter) CreateUser(ctx interface{}, user interface{}) *Repository_CreateUser_Call {
	return &Repository_CreateUser_Call{Call: _e.mock.On("CreateUser", ctx, user)}
}

func (_c *Repository_CreateUser_Call) Run(run func(ctx context.Context, user *models.User)) *Repository_CreateUser_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*models.User))
	})
	return _c
}

func (_c *Repository_CreateUser_Call) Return(_a0 error) *Repository_CreateUser_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Repository_CreateUser_Call) RunAndReturn(run func(context.Context, *models.User) error) *Repository_CreateUser_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteInbox provides a mock function with given fields: ctx, id
func (_m *Repository) DeleteInbox(ctx context.Context, id int) error {
	ret := _m.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for DeleteInbox")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, int) error); ok {
		r0 = rf(ctx, id)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Repository_DeleteInbox_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteInbox'
type Repository_DeleteInbox_Call struct {
	*mock.Call
}

// DeleteInbox is a helper method to define mock.On call
//   - ctx context.Context
//   - id int
func (_e *Repository_Expecter) DeleteInbox(ctx interface{}, id interface{}) *Repository_DeleteInbox_Call {
	return &Repository_DeleteInbox_Call{Call: _e.mock.On("DeleteInbox", ctx, id)}
}

func (_c *Repository_DeleteInbox_Call) Run(run func(ctx context.Context, id int)) *Repository_DeleteInbox_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int))
	})
	return _c
}

func (_c *Repository_DeleteInbox_Call) Return(_a0 error) *Repository_DeleteInbox_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Repository_DeleteInbox_Call) RunAndReturn(run func(context.Context, int) error) *Repository_DeleteInbox_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteProject provides a mock function with given fields: ctx, id
func (_m *Repository) DeleteProject(ctx context.Context, id int) error {
	ret := _m.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for DeleteProject")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, int) error); ok {
		r0 = rf(ctx, id)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Repository_DeleteProject_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteProject'
type Repository_DeleteProject_Call struct {
	*mock.Call
}

// DeleteProject is a helper method to define mock.On call
//   - ctx context.Context
//   - id int
func (_e *Repository_Expecter) DeleteProject(ctx interface{}, id interface{}) *Repository_DeleteProject_Call {
	return &Repository_DeleteProject_Call{Call: _e.mock.On("DeleteProject", ctx, id)}
}

func (_c *Repository_DeleteProject_Call) Run(run func(ctx context.Context, id int)) *Repository_DeleteProject_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int))
	})
	return _c
}

func (_c *Repository_DeleteProject_Call) Return(_a0 error) *Repository_DeleteProject_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Repository_DeleteProject_Call) RunAndReturn(run func(context.Context, int) error) *Repository_DeleteProject_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteRule provides a mock function with given fields: ctx, id
func (_m *Repository) DeleteRule(ctx context.Context, id int) error {
	ret := _m.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for DeleteRule")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, int) error); ok {
		r0 = rf(ctx, id)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Repository_DeleteRule_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteRule'
type Repository_DeleteRule_Call struct {
	*mock.Call
}

// DeleteRule is a helper method to define mock.On call
//   - ctx context.Context
//   - id int
func (_e *Repository_Expecter) DeleteRule(ctx interface{}, id interface{}) *Repository_DeleteRule_Call {
	return &Repository_DeleteRule_Call{Call: _e.mock.On("DeleteRule", ctx, id)}
}

func (_c *Repository_DeleteRule_Call) Run(run func(ctx context.Context, id int)) *Repository_DeleteRule_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int))
	})
	return _c
}

func (_c *Repository_DeleteRule_Call) Return(_a0 error) *Repository_DeleteRule_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Repository_DeleteRule_Call) RunAndReturn(run func(context.Context, int) error) *Repository_DeleteRule_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteToken provides a mock function with given fields: ctx, tokenID
func (_m *Repository) DeleteToken(ctx context.Context, tokenID int) error {
	ret := _m.Called(ctx, tokenID)

	if len(ret) == 0 {
		panic("no return value specified for DeleteToken")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, int) error); ok {
		r0 = rf(ctx, tokenID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Repository_DeleteToken_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteToken'
type Repository_DeleteToken_Call struct {
	*mock.Call
}

// DeleteToken is a helper method to define mock.On call
//   - ctx context.Context
//   - tokenID int
func (_e *Repository_Expecter) DeleteToken(ctx interface{}, tokenID interface{}) *Repository_DeleteToken_Call {
	return &Repository_DeleteToken_Call{Call: _e.mock.On("DeleteToken", ctx, tokenID)}
}

func (_c *Repository_DeleteToken_Call) Run(run func(ctx context.Context, tokenID int)) *Repository_DeleteToken_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int))
	})
	return _c
}

func (_c *Repository_DeleteToken_Call) Return(_a0 error) *Repository_DeleteToken_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Repository_DeleteToken_Call) RunAndReturn(run func(context.Context, int) error) *Repository_DeleteToken_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteUser provides a mock function with given fields: ctx, userId
func (_m *Repository) DeleteUser(ctx context.Context, userId int) error {
	ret := _m.Called(ctx, userId)

	if len(ret) == 0 {
		panic("no return value specified for DeleteUser")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, int) error); ok {
		r0 = rf(ctx, userId)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Repository_DeleteUser_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteUser'
type Repository_DeleteUser_Call struct {
	*mock.Call
}

// DeleteUser is a helper method to define mock.On call
//   - ctx context.Context
//   - userId int
func (_e *Repository_Expecter) DeleteUser(ctx interface{}, userId interface{}) *Repository_DeleteUser_Call {
	return &Repository_DeleteUser_Call{Call: _e.mock.On("DeleteUser", ctx, userId)}
}

func (_c *Repository_DeleteUser_Call) Run(run func(ctx context.Context, userId int)) *Repository_DeleteUser_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int))
	})
	return _c
}

func (_c *Repository_DeleteUser_Call) Return(_a0 error) *Repository_DeleteUser_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Repository_DeleteUser_Call) RunAndReturn(run func(context.Context, int) error) *Repository_DeleteUser_Call {
	_c.Call.Return(run)
	return _c
}

// GetInbox provides a mock function with given fields: ctx, id
func (_m *Repository) GetInbox(ctx context.Context, id int) (*models.Inbox, error) {
	ret := _m.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for GetInbox")
	}

	var r0 *models.Inbox
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, int) (*models.Inbox, error)); ok {
		return rf(ctx, id)
	}
	if rf, ok := ret.Get(0).(func(context.Context, int) *models.Inbox); ok {
		r0 = rf(ctx, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*models.Inbox)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, int) error); ok {
		r1 = rf(ctx, id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Repository_GetInbox_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetInbox'
type Repository_GetInbox_Call struct {
	*mock.Call
}

// GetInbox is a helper method to define mock.On call
//   - ctx context.Context
//   - id int
func (_e *Repository_Expecter) GetInbox(ctx interface{}, id interface{}) *Repository_GetInbox_Call {
	return &Repository_GetInbox_Call{Call: _e.mock.On("GetInbox", ctx, id)}
}

func (_c *Repository_GetInbox_Call) Run(run func(ctx context.Context, id int)) *Repository_GetInbox_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int))
	})
	return _c
}

func (_c *Repository_GetInbox_Call) Return(_a0 *models.Inbox, _a1 error) *Repository_GetInbox_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Repository_GetInbox_Call) RunAndReturn(run func(context.Context, int) (*models.Inbox, error)) *Repository_GetInbox_Call {
	_c.Call.Return(run)
	return _c
}

// GetInboxByEmail provides a mock function with given fields: ctx, email
func (_m *Repository) GetInboxByEmail(ctx context.Context, email string) (*models.Inbox, error) {
	ret := _m.Called(ctx, email)

	if len(ret) == 0 {
		panic("no return value specified for GetInboxByEmail")
	}

	var r0 *models.Inbox
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (*models.Inbox, error)); ok {
		return rf(ctx, email)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) *models.Inbox); ok {
		r0 = rf(ctx, email)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*models.Inbox)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, email)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Repository_GetInboxByEmail_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetInboxByEmail'
type Repository_GetInboxByEmail_Call struct {
	*mock.Call
}

// GetInboxByEmail is a helper method to define mock.On call
//   - ctx context.Context
//   - email string
func (_e *Repository_Expecter) GetInboxByEmail(ctx interface{}, email interface{}) *Repository_GetInboxByEmail_Call {
	return &Repository_GetInboxByEmail_Call{Call: _e.mock.On("GetInboxByEmail", ctx, email)}
}

func (_c *Repository_GetInboxByEmail_Call) Run(run func(ctx context.Context, email string)) *Repository_GetInboxByEmail_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *Repository_GetInboxByEmail_Call) Return(_a0 *models.Inbox, _a1 error) *Repository_GetInboxByEmail_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Repository_GetInboxByEmail_Call) RunAndReturn(run func(context.Context, string) (*models.Inbox, error)) *Repository_GetInboxByEmail_Call {
	_c.Call.Return(run)
	return _c
}

// GetMessage provides a mock function with given fields: ctx, id
func (_m *Repository) GetMessage(ctx context.Context, id int) (*models.Message, error) {
	ret := _m.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for GetMessage")
	}

	var r0 *models.Message
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, int) (*models.Message, error)); ok {
		return rf(ctx, id)
	}
	if rf, ok := ret.Get(0).(func(context.Context, int) *models.Message); ok {
		r0 = rf(ctx, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*models.Message)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, int) error); ok {
		r1 = rf(ctx, id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Repository_GetMessage_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetMessage'
type Repository_GetMessage_Call struct {
	*mock.Call
}

// GetMessage is a helper method to define mock.On call
//   - ctx context.Context
//   - id int
func (_e *Repository_Expecter) GetMessage(ctx interface{}, id interface{}) *Repository_GetMessage_Call {
	return &Repository_GetMessage_Call{Call: _e.mock.On("GetMessage", ctx, id)}
}

func (_c *Repository_GetMessage_Call) Run(run func(ctx context.Context, id int)) *Repository_GetMessage_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int))
	})
	return _c
}

func (_c *Repository_GetMessage_Call) Return(_a0 *models.Message, _a1 error) *Repository_GetMessage_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Repository_GetMessage_Call) RunAndReturn(run func(context.Context, int) (*models.Message, error)) *Repository_GetMessage_Call {
	_c.Call.Return(run)
	return _c
}

// GetProject provides a mock function with given fields: ctx, id
func (_m *Repository) GetProject(ctx context.Context, id int) (*models.Project, error) {
	ret := _m.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for GetProject")
	}

	var r0 *models.Project
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, int) (*models.Project, error)); ok {
		return rf(ctx, id)
	}
	if rf, ok := ret.Get(0).(func(context.Context, int) *models.Project); ok {
		r0 = rf(ctx, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*models.Project)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, int) error); ok {
		r1 = rf(ctx, id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Repository_GetProject_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetProject'
type Repository_GetProject_Call struct {
	*mock.Call
}

// GetProject is a helper method to define mock.On call
//   - ctx context.Context
//   - id int
func (_e *Repository_Expecter) GetProject(ctx interface{}, id interface{}) *Repository_GetProject_Call {
	return &Repository_GetProject_Call{Call: _e.mock.On("GetProject", ctx, id)}
}

func (_c *Repository_GetProject_Call) Run(run func(ctx context.Context, id int)) *Repository_GetProject_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int))
	})
	return _c
}

func (_c *Repository_GetProject_Call) Return(_a0 *models.Project, _a1 error) *Repository_GetProject_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Repository_GetProject_Call) RunAndReturn(run func(context.Context, int) (*models.Project, error)) *Repository_GetProject_Call {
	_c.Call.Return(run)
	return _c
}

// GetRule provides a mock function with given fields: ctx, id
func (_m *Repository) GetRule(ctx context.Context, id int) (*models.ForwardRule, error) {
	ret := _m.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for GetRule")
	}

	var r0 *models.ForwardRule
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, int) (*models.ForwardRule, error)); ok {
		return rf(ctx, id)
	}
	if rf, ok := ret.Get(0).(func(context.Context, int) *models.ForwardRule); ok {
		r0 = rf(ctx, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*models.ForwardRule)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, int) error); ok {
		r1 = rf(ctx, id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Repository_GetRule_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetRule'
type Repository_GetRule_Call struct {
	*mock.Call
}

// GetRule is a helper method to define mock.On call
//   - ctx context.Context
//   - id int
func (_e *Repository_Expecter) GetRule(ctx interface{}, id interface{}) *Repository_GetRule_Call {
	return &Repository_GetRule_Call{Call: _e.mock.On("GetRule", ctx, id)}
}

func (_c *Repository_GetRule_Call) Run(run func(ctx context.Context, id int)) *Repository_GetRule_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int))
	})
	return _c
}

func (_c *Repository_GetRule_Call) Return(_a0 *models.ForwardRule, _a1 error) *Repository_GetRule_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Repository_GetRule_Call) RunAndReturn(run func(context.Context, int) (*models.ForwardRule, error)) *Repository_GetRule_Call {
	_c.Call.Return(run)
	return _c
}

// GetTokenByUser provides a mock function with given fields: ctx, userID, tokenID
func (_m *Repository) GetTokenByUser(ctx context.Context, userID int, tokenID int) (*models.Token, error) {
	ret := _m.Called(ctx, userID, tokenID)

	if len(ret) == 0 {
		panic("no return value specified for GetTokenByUser")
	}

	var r0 *models.Token
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, int, int) (*models.Token, error)); ok {
		return rf(ctx, userID, tokenID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, int, int) *models.Token); ok {
		r0 = rf(ctx, userID, tokenID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*models.Token)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, int, int) error); ok {
		r1 = rf(ctx, userID, tokenID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Repository_GetTokenByUser_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetTokenByUser'
type Repository_GetTokenByUser_Call struct {
	*mock.Call
}

// GetTokenByUser is a helper method to define mock.On call
//   - ctx context.Context
//   - userID int
//   - tokenID int
func (_e *Repository_Expecter) GetTokenByUser(ctx interface{}, userID interface{}, tokenID interface{}) *Repository_GetTokenByUser_Call {
	return &Repository_GetTokenByUser_Call{Call: _e.mock.On("GetTokenByUser", ctx, userID, tokenID)}
}

func (_c *Repository_GetTokenByUser_Call) Run(run func(ctx context.Context, userID int, tokenID int)) *Repository_GetTokenByUser_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int), args[2].(int))
	})
	return _c
}

func (_c *Repository_GetTokenByUser_Call) Return(_a0 *models.Token, _a1 error) *Repository_GetTokenByUser_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Repository_GetTokenByUser_Call) RunAndReturn(run func(context.Context, int, int) (*models.Token, error)) *Repository_GetTokenByUser_Call {
	_c.Call.Return(run)
	return _c
}

// GetUser provides a mock function with given fields: ctx, id
func (_m *Repository) GetUser(ctx context.Context, id int) (*models.User, error) {
	ret := _m.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for GetUser")
	}

	var r0 *models.User
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, int) (*models.User, error)); ok {
		return rf(ctx, id)
	}
	if rf, ok := ret.Get(0).(func(context.Context, int) *models.User); ok {
		r0 = rf(ctx, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*models.User)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, int) error); ok {
		r1 = rf(ctx, id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Repository_GetUser_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetUser'
type Repository_GetUser_Call struct {
	*mock.Call
}

// GetUser is a helper method to define mock.On call
//   - ctx context.Context
//   - id int
func (_e *Repository_Expecter) GetUser(ctx interface{}, id interface{}) *Repository_GetUser_Call {
	return &Repository_GetUser_Call{Call: _e.mock.On("GetUser", ctx, id)}
}

func (_c *Repository_GetUser_Call) Run(run func(ctx context.Context, id int)) *Repository_GetUser_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int))
	})
	return _c
}

func (_c *Repository_GetUser_Call) Return(_a0 *models.User, _a1 error) *Repository_GetUser_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Repository_GetUser_Call) RunAndReturn(run func(context.Context, int) (*models.User, error)) *Repository_GetUser_Call {
	_c.Call.Return(run)
	return _c
}

// GetUserByUsername provides a mock function with given fields: ctx, username
func (_m *Repository) GetUserByUsername(ctx context.Context, username string) (*models.User, error) {
	ret := _m.Called(ctx, username)

	if len(ret) == 0 {
		panic("no return value specified for GetUserByUsername")
	}

	var r0 *models.User
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (*models.User, error)); ok {
		return rf(ctx, username)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) *models.User); ok {
		r0 = rf(ctx, username)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*models.User)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, username)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Repository_GetUserByUsername_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetUserByUsername'
type Repository_GetUserByUsername_Call struct {
	*mock.Call
}

// GetUserByUsername is a helper method to define mock.On call
//   - ctx context.Context
//   - username string
func (_e *Repository_Expecter) GetUserByUsername(ctx interface{}, username interface{}) *Repository_GetUserByUsername_Call {
	return &Repository_GetUserByUsername_Call{Call: _e.mock.On("GetUserByUsername", ctx, username)}
}

func (_c *Repository_GetUserByUsername_Call) Run(run func(ctx context.Context, username string)) *Repository_GetUserByUsername_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *Repository_GetUserByUsername_Call) Return(_a0 *models.User, _a1 error) *Repository_GetUserByUsername_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Repository_GetUserByUsername_Call) RunAndReturn(run func(context.Context, string) (*models.User, error)) *Repository_GetUserByUsername_Call {
	_c.Call.Return(run)
	return _c
}

// ListInboxesByProject provides a mock function with given fields: ctx, projectID, limit, offset
func (_m *Repository) ListInboxesByProject(ctx context.Context, projectID int, limit int, offset int) ([]*models.Inbox, int, error) {
	ret := _m.Called(ctx, projectID, limit, offset)

	if len(ret) == 0 {
		panic("no return value specified for ListInboxesByProject")
	}

	var r0 []*models.Inbox
	var r1 int
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, int, int, int) ([]*models.Inbox, int, error)); ok {
		return rf(ctx, projectID, limit, offset)
	}
	if rf, ok := ret.Get(0).(func(context.Context, int, int, int) []*models.Inbox); ok {
		r0 = rf(ctx, projectID, limit, offset)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*models.Inbox)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, int, int, int) int); ok {
		r1 = rf(ctx, projectID, limit, offset)
	} else {
		r1 = ret.Get(1).(int)
	}

	if rf, ok := ret.Get(2).(func(context.Context, int, int, int) error); ok {
		r2 = rf(ctx, projectID, limit, offset)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// Repository_ListInboxesByProject_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListInboxesByProject'
type Repository_ListInboxesByProject_Call struct {
	*mock.Call
}

// ListInboxesByProject is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID int
//   - limit int
//   - offset int
func (_e *Repository_Expecter) ListInboxesByProject(ctx interface{}, projectID interface{}, limit interface{}, offset interface{}) *Repository_ListInboxesByProject_Call {
	return &Repository_ListInboxesByProject_Call{Call: _e.mock.On("ListInboxesByProject", ctx, projectID, limit, offset)}
}

func (_c *Repository_ListInboxesByProject_Call) Run(run func(ctx context.Context, projectID int, limit int, offset int)) *Repository_ListInboxesByProject_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int), args[2].(int), args[3].(int))
	})
	return _c
}

func (_c *Repository_ListInboxesByProject_Call) Return(_a0 []*models.Inbox, _a1 int, _a2 error) *Repository_ListInboxesByProject_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *Repository_ListInboxesByProject_Call) RunAndReturn(run func(context.Context, int, int, int) ([]*models.Inbox, int, error)) *Repository_ListInboxesByProject_Call {
	_c.Call.Return(run)
	return _c
}

// ListMessagesByInbox provides a mock function with given fields: ctx, inboxID, limit, offset
func (_m *Repository) ListMessagesByInbox(ctx context.Context, inboxID int, limit int, offset int) ([]*models.Message, int, error) {
	ret := _m.Called(ctx, inboxID, limit, offset)

	if len(ret) == 0 {
		panic("no return value specified for ListMessagesByInbox")
	}

	var r0 []*models.Message
	var r1 int
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, int, int, int) ([]*models.Message, int, error)); ok {
		return rf(ctx, inboxID, limit, offset)
	}
	if rf, ok := ret.Get(0).(func(context.Context, int, int, int) []*models.Message); ok {
		r0 = rf(ctx, inboxID, limit, offset)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*models.Message)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, int, int, int) int); ok {
		r1 = rf(ctx, inboxID, limit, offset)
	} else {
		r1 = ret.Get(1).(int)
	}

	if rf, ok := ret.Get(2).(func(context.Context, int, int, int) error); ok {
		r2 = rf(ctx, inboxID, limit, offset)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// Repository_ListMessagesByInbox_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListMessagesByInbox'
type Repository_ListMessagesByInbox_Call struct {
	*mock.Call
}

// ListMessagesByInbox is a helper method to define mock.On call
//   - ctx context.Context
//   - inboxID int
//   - limit int
//   - offset int
func (_e *Repository_Expecter) ListMessagesByInbox(ctx interface{}, inboxID interface{}, limit interface{}, offset interface{}) *Repository_ListMessagesByInbox_Call {
	return &Repository_ListMessagesByInbox_Call{Call: _e.mock.On("ListMessagesByInbox", ctx, inboxID, limit, offset)}
}

func (_c *Repository_ListMessagesByInbox_Call) Run(run func(ctx context.Context, inboxID int, limit int, offset int)) *Repository_ListMessagesByInbox_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int), args[2].(int), args[3].(int))
	})
	return _c
}

func (_c *Repository_ListMessagesByInbox_Call) Return(_a0 []*models.Message, _a1 int, _a2 error) *Repository_ListMessagesByInbox_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *Repository_ListMessagesByInbox_Call) RunAndReturn(run func(context.Context, int, int, int) ([]*models.Message, int, error)) *Repository_ListMessagesByInbox_Call {
	_c.Call.Return(run)
	return _c
}

// ListProjects provides a mock function with given fields: ctx, limit, offset
func (_m *Repository) ListProjects(ctx context.Context, limit int, offset int) ([]*models.Project, int, error) {
	ret := _m.Called(ctx, limit, offset)

	if len(ret) == 0 {
		panic("no return value specified for ListProjects")
	}

	var r0 []*models.Project
	var r1 int
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, int, int) ([]*models.Project, int, error)); ok {
		return rf(ctx, limit, offset)
	}
	if rf, ok := ret.Get(0).(func(context.Context, int, int) []*models.Project); ok {
		r0 = rf(ctx, limit, offset)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*models.Project)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, int, int) int); ok {
		r1 = rf(ctx, limit, offset)
	} else {
		r1 = ret.Get(1).(int)
	}

	if rf, ok := ret.Get(2).(func(context.Context, int, int) error); ok {
		r2 = rf(ctx, limit, offset)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// Repository_ListProjects_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListProjects'
type Repository_ListProjects_Call struct {
	*mock.Call
}

// ListProjects is a helper method to define mock.On call
//   - ctx context.Context
//   - limit int
//   - offset int
func (_e *Repository_Expecter) ListProjects(ctx interface{}, limit interface{}, offset interface{}) *Repository_ListProjects_Call {
	return &Repository_ListProjects_Call{Call: _e.mock.On("ListProjects", ctx, limit, offset)}
}

func (_c *Repository_ListProjects_Call) Run(run func(ctx context.Context, limit int, offset int)) *Repository_ListProjects_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int), args[2].(int))
	})
	return _c
}

func (_c *Repository_ListProjects_Call) Return(_a0 []*models.Project, _a1 int, _a2 error) *Repository_ListProjects_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *Repository_ListProjects_Call) RunAndReturn(run func(context.Context, int, int) ([]*models.Project, int, error)) *Repository_ListProjects_Call {
	_c.Call.Return(run)
	return _c
}

// ListProjectsByUser provides a mock function with given fields: ctx, userID, limit, offset
func (_m *Repository) ListProjectsByUser(ctx context.Context, userID int, limit int, offset int) ([]*models.Project, int, error) {
	ret := _m.Called(ctx, userID, limit, offset)

	if len(ret) == 0 {
		panic("no return value specified for ListProjectsByUser")
	}

	var r0 []*models.Project
	var r1 int
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, int, int, int) ([]*models.Project, int, error)); ok {
		return rf(ctx, userID, limit, offset)
	}
	if rf, ok := ret.Get(0).(func(context.Context, int, int, int) []*models.Project); ok {
		r0 = rf(ctx, userID, limit, offset)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*models.Project)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, int, int, int) int); ok {
		r1 = rf(ctx, userID, limit, offset)
	} else {
		r1 = ret.Get(1).(int)
	}

	if rf, ok := ret.Get(2).(func(context.Context, int, int, int) error); ok {
		r2 = rf(ctx, userID, limit, offset)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// Repository_ListProjectsByUser_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListProjectsByUser'
type Repository_ListProjectsByUser_Call struct {
	*mock.Call
}

// ListProjectsByUser is a helper method to define mock.On call
//   - ctx context.Context
//   - userID int
//   - limit int
//   - offset int
func (_e *Repository_Expecter) ListProjectsByUser(ctx interface{}, userID interface{}, limit interface{}, offset interface{}) *Repository_ListProjectsByUser_Call {
	return &Repository_ListProjectsByUser_Call{Call: _e.mock.On("ListProjectsByUser", ctx, userID, limit, offset)}
}

func (_c *Repository_ListProjectsByUser_Call) Run(run func(ctx context.Context, userID int, limit int, offset int)) *Repository_ListProjectsByUser_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int), args[2].(int), args[3].(int))
	})
	return _c
}

func (_c *Repository_ListProjectsByUser_Call) Return(_a0 []*models.Project, _a1 int, _a2 error) *Repository_ListProjectsByUser_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *Repository_ListProjectsByUser_Call) RunAndReturn(run func(context.Context, int, int, int) ([]*models.Project, int, error)) *Repository_ListProjectsByUser_Call {
	_c.Call.Return(run)
	return _c
}

// ListRules provides a mock function with given fields: ctx, limit, offset
func (_m *Repository) ListRules(ctx context.Context, limit int, offset int) ([]*models.ForwardRule, int, error) {
	ret := _m.Called(ctx, limit, offset)

	if len(ret) == 0 {
		panic("no return value specified for ListRules")
	}

	var r0 []*models.ForwardRule
	var r1 int
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, int, int) ([]*models.ForwardRule, int, error)); ok {
		return rf(ctx, limit, offset)
	}
	if rf, ok := ret.Get(0).(func(context.Context, int, int) []*models.ForwardRule); ok {
		r0 = rf(ctx, limit, offset)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*models.ForwardRule)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, int, int) int); ok {
		r1 = rf(ctx, limit, offset)
	} else {
		r1 = ret.Get(1).(int)
	}

	if rf, ok := ret.Get(2).(func(context.Context, int, int) error); ok {
		r2 = rf(ctx, limit, offset)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// Repository_ListRules_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListRules'
type Repository_ListRules_Call struct {
	*mock.Call
}

// ListRules is a helper method to define mock.On call
//   - ctx context.Context
//   - limit int
//   - offset int
func (_e *Repository_Expecter) ListRules(ctx interface{}, limit interface{}, offset interface{}) *Repository_ListRules_Call {
	return &Repository_ListRules_Call{Call: _e.mock.On("ListRules", ctx, limit, offset)}
}

func (_c *Repository_ListRules_Call) Run(run func(ctx context.Context, limit int, offset int)) *Repository_ListRules_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int), args[2].(int))
	})
	return _c
}

func (_c *Repository_ListRules_Call) Return(_a0 []*models.ForwardRule, _a1 int, _a2 error) *Repository_ListRules_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *Repository_ListRules_Call) RunAndReturn(run func(context.Context, int, int) ([]*models.ForwardRule, int, error)) *Repository_ListRules_Call {
	_c.Call.Return(run)
	return _c
}

// ListRulesByInbox provides a mock function with given fields: ctx, inboxID, limit, offset
func (_m *Repository) ListRulesByInbox(ctx context.Context, inboxID int, limit int, offset int) ([]*models.ForwardRule, int, error) {
	ret := _m.Called(ctx, inboxID, limit, offset)

	if len(ret) == 0 {
		panic("no return value specified for ListRulesByInbox")
	}

	var r0 []*models.ForwardRule
	var r1 int
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, int, int, int) ([]*models.ForwardRule, int, error)); ok {
		return rf(ctx, inboxID, limit, offset)
	}
	if rf, ok := ret.Get(0).(func(context.Context, int, int, int) []*models.ForwardRule); ok {
		r0 = rf(ctx, inboxID, limit, offset)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*models.ForwardRule)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, int, int, int) int); ok {
		r1 = rf(ctx, inboxID, limit, offset)
	} else {
		r1 = ret.Get(1).(int)
	}

	if rf, ok := ret.Get(2).(func(context.Context, int, int, int) error); ok {
		r2 = rf(ctx, inboxID, limit, offset)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// Repository_ListRulesByInbox_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListRulesByInbox'
type Repository_ListRulesByInbox_Call struct {
	*mock.Call
}

// ListRulesByInbox is a helper method to define mock.On call
//   - ctx context.Context
//   - inboxID int
//   - limit int
//   - offset int
func (_e *Repository_Expecter) ListRulesByInbox(ctx interface{}, inboxID interface{}, limit interface{}, offset interface{}) *Repository_ListRulesByInbox_Call {
	return &Repository_ListRulesByInbox_Call{Call: _e.mock.On("ListRulesByInbox", ctx, inboxID, limit, offset)}
}

func (_c *Repository_ListRulesByInbox_Call) Run(run func(ctx context.Context, inboxID int, limit int, offset int)) *Repository_ListRulesByInbox_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int), args[2].(int), args[3].(int))
	})
	return _c
}

func (_c *Repository_ListRulesByInbox_Call) Return(_a0 []*models.ForwardRule, _a1 int, _a2 error) *Repository_ListRulesByInbox_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *Repository_ListRulesByInbox_Call) RunAndReturn(run func(context.Context, int, int, int) ([]*models.ForwardRule, int, error)) *Repository_ListRulesByInbox_Call {
	_c.Call.Return(run)
	return _c
}

// ListTokensByUser provides a mock function with given fields: ctx, userID, limit, offset
func (_m *Repository) ListTokensByUser(ctx context.Context, userID int, limit int, offset int) ([]*models.Token, int, error) {
	ret := _m.Called(ctx, userID, limit, offset)

	if len(ret) == 0 {
		panic("no return value specified for ListTokensByUser")
	}

	var r0 []*models.Token
	var r1 int
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, int, int, int) ([]*models.Token, int, error)); ok {
		return rf(ctx, userID, limit, offset)
	}
	if rf, ok := ret.Get(0).(func(context.Context, int, int, int) []*models.Token); ok {
		r0 = rf(ctx, userID, limit, offset)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*models.Token)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, int, int, int) int); ok {
		r1 = rf(ctx, userID, limit, offset)
	} else {
		r1 = ret.Get(1).(int)
	}

	if rf, ok := ret.Get(2).(func(context.Context, int, int, int) error); ok {
		r2 = rf(ctx, userID, limit, offset)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// Repository_ListTokensByUser_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListTokensByUser'
type Repository_ListTokensByUser_Call struct {
	*mock.Call
}

// ListTokensByUser is a helper method to define mock.On call
//   - ctx context.Context
//   - userID int
//   - limit int
//   - offset int
func (_e *Repository_Expecter) ListTokensByUser(ctx interface{}, userID interface{}, limit interface{}, offset interface{}) *Repository_ListTokensByUser_Call {
	return &Repository_ListTokensByUser_Call{Call: _e.mock.On("ListTokensByUser", ctx, userID, limit, offset)}
}

func (_c *Repository_ListTokensByUser_Call) Run(run func(ctx context.Context, userID int, limit int, offset int)) *Repository_ListTokensByUser_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int), args[2].(int), args[3].(int))
	})
	return _c
}

func (_c *Repository_ListTokensByUser_Call) Return(_a0 []*models.Token, _a1 int, _a2 error) *Repository_ListTokensByUser_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *Repository_ListTokensByUser_Call) RunAndReturn(run func(context.Context, int, int, int) ([]*models.Token, int, error)) *Repository_ListTokensByUser_Call {
	_c.Call.Return(run)
	return _c
}

// ListUsers provides a mock function with given fields: ctx, limit, offset
func (_m *Repository) ListUsers(ctx context.Context, limit int, offset int) ([]*models.User, int, error) {
	ret := _m.Called(ctx, limit, offset)

	if len(ret) == 0 {
		panic("no return value specified for ListUsers")
	}

	var r0 []*models.User
	var r1 int
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, int, int) ([]*models.User, int, error)); ok {
		return rf(ctx, limit, offset)
	}
	if rf, ok := ret.Get(0).(func(context.Context, int, int) []*models.User); ok {
		r0 = rf(ctx, limit, offset)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*models.User)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, int, int) int); ok {
		r1 = rf(ctx, limit, offset)
	} else {
		r1 = ret.Get(1).(int)
	}

	if rf, ok := ret.Get(2).(func(context.Context, int, int) error); ok {
		r2 = rf(ctx, limit, offset)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// Repository_ListUsers_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListUsers'
type Repository_ListUsers_Call struct {
	*mock.Call
}

// ListUsers is a helper method to define mock.On call
//   - ctx context.Context
//   - limit int
//   - offset int
func (_e *Repository_Expecter) ListUsers(ctx interface{}, limit interface{}, offset interface{}) *Repository_ListUsers_Call {
	return &Repository_ListUsers_Call{Call: _e.mock.On("ListUsers", ctx, limit, offset)}
}

func (_c *Repository_ListUsers_Call) Run(run func(ctx context.Context, limit int, offset int)) *Repository_ListUsers_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int), args[2].(int))
	})
	return _c
}

func (_c *Repository_ListUsers_Call) Return(_a0 []*models.User, _a1 int, _a2 error) *Repository_ListUsers_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *Repository_ListUsers_Call) RunAndReturn(run func(context.Context, int, int) ([]*models.User, int, error)) *Repository_ListUsers_Call {
	_c.Call.Return(run)
	return _c
}

// ProjectAddUser provides a mock function with given fields: ctx, projectUser
func (_m *Repository) ProjectAddUser(ctx context.Context, projectUser *models.ProjectUser) error {
	ret := _m.Called(ctx, projectUser)

	if len(ret) == 0 {
		panic("no return value specified for ProjectAddUser")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *models.ProjectUser) error); ok {
		r0 = rf(ctx, projectUser)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Repository_ProjectAddUser_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ProjectAddUser'
type Repository_ProjectAddUser_Call struct {
	*mock.Call
}

// ProjectAddUser is a helper method to define mock.On call
//   - ctx context.Context
//   - projectUser *models.ProjectUser
func (_e *Repository_Expecter) ProjectAddUser(ctx interface{}, projectUser interface{}) *Repository_ProjectAddUser_Call {
	return &Repository_ProjectAddUser_Call{Call: _e.mock.On("ProjectAddUser", ctx, projectUser)}
}

func (_c *Repository_ProjectAddUser_Call) Run(run func(ctx context.Context, projectUser *models.ProjectUser)) *Repository_ProjectAddUser_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*models.ProjectUser))
	})
	return _c
}

func (_c *Repository_ProjectAddUser_Call) Return(_a0 error) *Repository_ProjectAddUser_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Repository_ProjectAddUser_Call) RunAndReturn(run func(context.Context, *models.ProjectUser) error) *Repository_ProjectAddUser_Call {
	_c.Call.Return(run)
	return _c
}

// ProjectRemoveUser provides a mock function with given fields: ctx, projectID, userID
func (_m *Repository) ProjectRemoveUser(ctx context.Context, projectID int, userID int) error {
	ret := _m.Called(ctx, projectID, userID)

	if len(ret) == 0 {
		panic("no return value specified for ProjectRemoveUser")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, int, int) error); ok {
		r0 = rf(ctx, projectID, userID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Repository_ProjectRemoveUser_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ProjectRemoveUser'
type Repository_ProjectRemoveUser_Call struct {
	*mock.Call
}

// ProjectRemoveUser is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID int
//   - userID int
func (_e *Repository_Expecter) ProjectRemoveUser(ctx interface{}, projectID interface{}, userID interface{}) *Repository_ProjectRemoveUser_Call {
	return &Repository_ProjectRemoveUser_Call{Call: _e.mock.On("ProjectRemoveUser", ctx, projectID, userID)}
}

func (_c *Repository_ProjectRemoveUser_Call) Run(run func(ctx context.Context, projectID int, userID int)) *Repository_ProjectRemoveUser_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int), args[2].(int))
	})
	return _c
}

func (_c *Repository_ProjectRemoveUser_Call) Return(_a0 error) *Repository_ProjectRemoveUser_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Repository_ProjectRemoveUser_Call) RunAndReturn(run func(context.Context, int, int) error) *Repository_ProjectRemoveUser_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateInbox provides a mock function with given fields: ctx, inbox
func (_m *Repository) UpdateInbox(ctx context.Context, inbox *models.Inbox) error {
	ret := _m.Called(ctx, inbox)

	if len(ret) == 0 {
		panic("no return value specified for UpdateInbox")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *models.Inbox) error); ok {
		r0 = rf(ctx, inbox)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Repository_UpdateInbox_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateInbox'
type Repository_UpdateInbox_Call struct {
	*mock.Call
}

// UpdateInbox is a helper method to define mock.On call
//   - ctx context.Context
//   - inbox *models.Inbox
func (_e *Repository_Expecter) UpdateInbox(ctx interface{}, inbox interface{}) *Repository_UpdateInbox_Call {
	return &Repository_UpdateInbox_Call{Call: _e.mock.On("UpdateInbox", ctx, inbox)}
}

func (_c *Repository_UpdateInbox_Call) Run(run func(ctx context.Context, inbox *models.Inbox)) *Repository_UpdateInbox_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*models.Inbox))
	})
	return _c
}

func (_c *Repository_UpdateInbox_Call) Return(_a0 error) *Repository_UpdateInbox_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Repository_UpdateInbox_Call) RunAndReturn(run func(context.Context, *models.Inbox) error) *Repository_UpdateInbox_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateProject provides a mock function with given fields: ctx, project
func (_m *Repository) UpdateProject(ctx context.Context, project *models.Project) error {
	ret := _m.Called(ctx, project)

	if len(ret) == 0 {
		panic("no return value specified for UpdateProject")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *models.Project) error); ok {
		r0 = rf(ctx, project)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Repository_UpdateProject_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateProject'
type Repository_UpdateProject_Call struct {
	*mock.Call
}

// UpdateProject is a helper method to define mock.On call
//   - ctx context.Context
//   - project *models.Project
func (_e *Repository_Expecter) UpdateProject(ctx interface{}, project interface{}) *Repository_UpdateProject_Call {
	return &Repository_UpdateProject_Call{Call: _e.mock.On("UpdateProject", ctx, project)}
}

func (_c *Repository_UpdateProject_Call) Run(run func(ctx context.Context, project *models.Project)) *Repository_UpdateProject_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*models.Project))
	})
	return _c
}

func (_c *Repository_UpdateProject_Call) Return(_a0 error) *Repository_UpdateProject_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Repository_UpdateProject_Call) RunAndReturn(run func(context.Context, *models.Project) error) *Repository_UpdateProject_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateRule provides a mock function with given fields: ctx, rule
func (_m *Repository) UpdateRule(ctx context.Context, rule *models.ForwardRule) error {
	ret := _m.Called(ctx, rule)

	if len(ret) == 0 {
		panic("no return value specified for UpdateRule")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *models.ForwardRule) error); ok {
		r0 = rf(ctx, rule)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Repository_UpdateRule_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateRule'
type Repository_UpdateRule_Call struct {
	*mock.Call
}

// UpdateRule is a helper method to define mock.On call
//   - ctx context.Context
//   - rule *models.ForwardRule
func (_e *Repository_Expecter) UpdateRule(ctx interface{}, rule interface{}) *Repository_UpdateRule_Call {
	return &Repository_UpdateRule_Call{Call: _e.mock.On("UpdateRule", ctx, rule)}
}

func (_c *Repository_UpdateRule_Call) Run(run func(ctx context.Context, rule *models.ForwardRule)) *Repository_UpdateRule_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*models.ForwardRule))
	})
	return _c
}

func (_c *Repository_UpdateRule_Call) Return(_a0 error) *Repository_UpdateRule_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Repository_UpdateRule_Call) RunAndReturn(run func(context.Context, *models.ForwardRule) error) *Repository_UpdateRule_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateUser provides a mock function with given fields: ctx, user
func (_m *Repository) UpdateUser(ctx context.Context, user *models.User) error {
	ret := _m.Called(ctx, user)

	if len(ret) == 0 {
		panic("no return value specified for UpdateUser")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *models.User) error); ok {
		r0 = rf(ctx, user)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Repository_UpdateUser_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateUser'
type Repository_UpdateUser_Call struct {
	*mock.Call
}

// UpdateUser is a helper method to define mock.On call
//   - ctx context.Context
//   - user *models.User
func (_e *Repository_Expecter) UpdateUser(ctx interface{}, user interface{}) *Repository_UpdateUser_Call {
	return &Repository_UpdateUser_Call{Call: _e.mock.On("UpdateUser", ctx, user)}
}

func (_c *Repository_UpdateUser_Call) Run(run func(ctx context.Context, user *models.User)) *Repository_UpdateUser_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*models.User))
	})
	return _c
}

func (_c *Repository_UpdateUser_Call) Return(_a0 error) *Repository_UpdateUser_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Repository_UpdateUser_Call) RunAndReturn(run func(context.Context, *models.User) error) *Repository_UpdateUser_Call {
	_c.Call.Return(run)
	return _c
}

// NewRepository creates a new instance of Repository. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewRepository(t interface {
	mock.TestingT
	Cleanup(func())
}) *Repository {
	mock := &Repository{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
