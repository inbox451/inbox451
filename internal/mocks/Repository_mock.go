// Code generated by mockery. DO NOT EDIT.

package mocks

import (
	models "inbox451/internal/models"

	mock "github.com/stretchr/testify/mock"
)

// Repository is an autogenerated mock type for the Repository type
type Repository struct {
	mock.Mock
}

type Repository_Expecter struct {
	mock *mock.Mock
}

func (_m *Repository) EXPECT() *Repository_Expecter {
	return &Repository_Expecter{mock: &_m.Mock}
}

// CreateInbox provides a mock function with given fields: inbox
func (_m *Repository) CreateInbox(inbox models.Inbox) (models.Inbox, error) {
	ret := _m.Called(inbox)

	if len(ret) == 0 {
		panic("no return value specified for CreateInbox")
	}

	var r0 models.Inbox
	var r1 error
	if rf, ok := ret.Get(0).(func(models.Inbox) (models.Inbox, error)); ok {
		return rf(inbox)
	}
	if rf, ok := ret.Get(0).(func(models.Inbox) models.Inbox); ok {
		r0 = rf(inbox)
	} else {
		r0 = ret.Get(0).(models.Inbox)
	}

	if rf, ok := ret.Get(1).(func(models.Inbox) error); ok {
		r1 = rf(inbox)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Repository_CreateInbox_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateInbox'
type Repository_CreateInbox_Call struct {
	*mock.Call
}

// CreateInbox is a helper method to define mock.On call
//   - inbox models.Inbox
func (_e *Repository_Expecter) CreateInbox(inbox interface{}) *Repository_CreateInbox_Call {
	return &Repository_CreateInbox_Call{Call: _e.mock.On("CreateInbox", inbox)}
}

func (_c *Repository_CreateInbox_Call) Run(run func(inbox models.Inbox)) *Repository_CreateInbox_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(models.Inbox))
	})
	return _c
}

func (_c *Repository_CreateInbox_Call) Return(_a0 models.Inbox, _a1 error) *Repository_CreateInbox_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Repository_CreateInbox_Call) RunAndReturn(run func(models.Inbox) (models.Inbox, error)) *Repository_CreateInbox_Call {
	_c.Call.Return(run)
	return _c
}

// CreateMessage provides a mock function with given fields: message
func (_m *Repository) CreateMessage(message models.Message) (models.Message, error) {
	ret := _m.Called(message)

	if len(ret) == 0 {
		panic("no return value specified for CreateMessage")
	}

	var r0 models.Message
	var r1 error
	if rf, ok := ret.Get(0).(func(models.Message) (models.Message, error)); ok {
		return rf(message)
	}
	if rf, ok := ret.Get(0).(func(models.Message) models.Message); ok {
		r0 = rf(message)
	} else {
		r0 = ret.Get(0).(models.Message)
	}

	if rf, ok := ret.Get(1).(func(models.Message) error); ok {
		r1 = rf(message)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Repository_CreateMessage_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateMessage'
type Repository_CreateMessage_Call struct {
	*mock.Call
}

// CreateMessage is a helper method to define mock.On call
//   - message models.Message
func (_e *Repository_Expecter) CreateMessage(message interface{}) *Repository_CreateMessage_Call {
	return &Repository_CreateMessage_Call{Call: _e.mock.On("CreateMessage", message)}
}

func (_c *Repository_CreateMessage_Call) Run(run func(message models.Message)) *Repository_CreateMessage_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(models.Message))
	})
	return _c
}

func (_c *Repository_CreateMessage_Call) Return(_a0 models.Message, _a1 error) *Repository_CreateMessage_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Repository_CreateMessage_Call) RunAndReturn(run func(models.Message) (models.Message, error)) *Repository_CreateMessage_Call {
	_c.Call.Return(run)
	return _c
}

// CreateProject provides a mock function with given fields: project
func (_m *Repository) CreateProject(project models.Project) (models.Project, error) {
	ret := _m.Called(project)

	if len(ret) == 0 {
		panic("no return value specified for CreateProject")
	}

	var r0 models.Project
	var r1 error
	if rf, ok := ret.Get(0).(func(models.Project) (models.Project, error)); ok {
		return rf(project)
	}
	if rf, ok := ret.Get(0).(func(models.Project) models.Project); ok {
		r0 = rf(project)
	} else {
		r0 = ret.Get(0).(models.Project)
	}

	if rf, ok := ret.Get(1).(func(models.Project) error); ok {
		r1 = rf(project)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Repository_CreateProject_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateProject'
type Repository_CreateProject_Call struct {
	*mock.Call
}

// CreateProject is a helper method to define mock.On call
//   - project models.Project
func (_e *Repository_Expecter) CreateProject(project interface{}) *Repository_CreateProject_Call {
	return &Repository_CreateProject_Call{Call: _e.mock.On("CreateProject", project)}
}

func (_c *Repository_CreateProject_Call) Run(run func(project models.Project)) *Repository_CreateProject_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(models.Project))
	})
	return _c
}

func (_c *Repository_CreateProject_Call) Return(_a0 models.Project, _a1 error) *Repository_CreateProject_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Repository_CreateProject_Call) RunAndReturn(run func(models.Project) (models.Project, error)) *Repository_CreateProject_Call {
	_c.Call.Return(run)
	return _c
}

// CreateRule provides a mock function with given fields: rule
func (_m *Repository) CreateRule(rule models.ForwardRule) (models.ForwardRule, error) {
	ret := _m.Called(rule)

	if len(ret) == 0 {
		panic("no return value specified for CreateRule")
	}

	var r0 models.ForwardRule
	var r1 error
	if rf, ok := ret.Get(0).(func(models.ForwardRule) (models.ForwardRule, error)); ok {
		return rf(rule)
	}
	if rf, ok := ret.Get(0).(func(models.ForwardRule) models.ForwardRule); ok {
		r0 = rf(rule)
	} else {
		r0 = ret.Get(0).(models.ForwardRule)
	}

	if rf, ok := ret.Get(1).(func(models.ForwardRule) error); ok {
		r1 = rf(rule)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Repository_CreateRule_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateRule'
type Repository_CreateRule_Call struct {
	*mock.Call
}

// CreateRule is a helper method to define mock.On call
//   - rule models.ForwardRule
func (_e *Repository_Expecter) CreateRule(rule interface{}) *Repository_CreateRule_Call {
	return &Repository_CreateRule_Call{Call: _e.mock.On("CreateRule", rule)}
}

func (_c *Repository_CreateRule_Call) Run(run func(rule models.ForwardRule)) *Repository_CreateRule_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(models.ForwardRule))
	})
	return _c
}

func (_c *Repository_CreateRule_Call) Return(_a0 models.ForwardRule, _a1 error) *Repository_CreateRule_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Repository_CreateRule_Call) RunAndReturn(run func(models.ForwardRule) (models.ForwardRule, error)) *Repository_CreateRule_Call {
	_c.Call.Return(run)
	return _c
}

// CreateToken provides a mock function with given fields: token
func (_m *Repository) CreateToken(token models.Token) (models.Token, error) {
	ret := _m.Called(token)

	if len(ret) == 0 {
		panic("no return value specified for CreateToken")
	}

	var r0 models.Token
	var r1 error
	if rf, ok := ret.Get(0).(func(models.Token) (models.Token, error)); ok {
		return rf(token)
	}
	if rf, ok := ret.Get(0).(func(models.Token) models.Token); ok {
		r0 = rf(token)
	} else {
		r0 = ret.Get(0).(models.Token)
	}

	if rf, ok := ret.Get(1).(func(models.Token) error); ok {
		r1 = rf(token)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Repository_CreateToken_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateToken'
type Repository_CreateToken_Call struct {
	*mock.Call
}

// CreateToken is a helper method to define mock.On call
//   - token models.Token
func (_e *Repository_Expecter) CreateToken(token interface{}) *Repository_CreateToken_Call {
	return &Repository_CreateToken_Call{Call: _e.mock.On("CreateToken", token)}
}

func (_c *Repository_CreateToken_Call) Run(run func(token models.Token)) *Repository_CreateToken_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(models.Token))
	})
	return _c
}

func (_c *Repository_CreateToken_Call) Return(_a0 models.Token, _a1 error) *Repository_CreateToken_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Repository_CreateToken_Call) RunAndReturn(run func(models.Token) (models.Token, error)) *Repository_CreateToken_Call {
	_c.Call.Return(run)
	return _c
}

// CreateUser provides a mock function with given fields: user
func (_m *Repository) CreateUser(user models.User) (models.User, error) {
	ret := _m.Called(user)

	if len(ret) == 0 {
		panic("no return value specified for CreateUser")
	}

	var r0 models.User
	var r1 error
	if rf, ok := ret.Get(0).(func(models.User) (models.User, error)); ok {
		return rf(user)
	}
	if rf, ok := ret.Get(0).(func(models.User) models.User); ok {
		r0 = rf(user)
	} else {
		r0 = ret.Get(0).(models.User)
	}

	if rf, ok := ret.Get(1).(func(models.User) error); ok {
		r1 = rf(user)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Repository_CreateUser_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateUser'
type Repository_CreateUser_Call struct {
	*mock.Call
}

// CreateUser is a helper method to define mock.On call
//   - user models.User
func (_e *Repository_Expecter) CreateUser(user interface{}) *Repository_CreateUser_Call {
	return &Repository_CreateUser_Call{Call: _e.mock.On("CreateUser", user)}
}

func (_c *Repository_CreateUser_Call) Run(run func(user models.User)) *Repository_CreateUser_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(models.User))
	})
	return _c
}

func (_c *Repository_CreateUser_Call) Return(_a0 models.User, _a1 error) *Repository_CreateUser_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Repository_CreateUser_Call) RunAndReturn(run func(models.User) (models.User, error)) *Repository_CreateUser_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteInbox provides a mock function with given fields: id
func (_m *Repository) DeleteInbox(id int) error {
	ret := _m.Called(id)

	if len(ret) == 0 {
		panic("no return value specified for DeleteInbox")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(int) error); ok {
		r0 = rf(id)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Repository_DeleteInbox_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteInbox'
type Repository_DeleteInbox_Call struct {
	*mock.Call
}

// DeleteInbox is a helper method to define mock.On call
//   - id int
func (_e *Repository_Expecter) DeleteInbox(id interface{}) *Repository_DeleteInbox_Call {
	return &Repository_DeleteInbox_Call{Call: _e.mock.On("DeleteInbox", id)}
}

func (_c *Repository_DeleteInbox_Call) Run(run func(id int)) *Repository_DeleteInbox_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(int))
	})
	return _c
}

func (_c *Repository_DeleteInbox_Call) Return(_a0 error) *Repository_DeleteInbox_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Repository_DeleteInbox_Call) RunAndReturn(run func(int) error) *Repository_DeleteInbox_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteMessage provides a mock function with given fields: messageID
func (_m *Repository) DeleteMessage(messageID int) error {
	ret := _m.Called(messageID)

	if len(ret) == 0 {
		panic("no return value specified for DeleteMessage")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(int) error); ok {
		r0 = rf(messageID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Repository_DeleteMessage_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteMessage'
type Repository_DeleteMessage_Call struct {
	*mock.Call
}

// DeleteMessage is a helper method to define mock.On call
//   - messageID int
func (_e *Repository_Expecter) DeleteMessage(messageID interface{}) *Repository_DeleteMessage_Call {
	return &Repository_DeleteMessage_Call{Call: _e.mock.On("DeleteMessage", messageID)}
}

func (_c *Repository_DeleteMessage_Call) Run(run func(messageID int)) *Repository_DeleteMessage_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(int))
	})
	return _c
}

func (_c *Repository_DeleteMessage_Call) Return(_a0 error) *Repository_DeleteMessage_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Repository_DeleteMessage_Call) RunAndReturn(run func(int) error) *Repository_DeleteMessage_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteProject provides a mock function with given fields: id
func (_m *Repository) DeleteProject(id int) error {
	ret := _m.Called(id)

	if len(ret) == 0 {
		panic("no return value specified for DeleteProject")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(int) error); ok {
		r0 = rf(id)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Repository_DeleteProject_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteProject'
type Repository_DeleteProject_Call struct {
	*mock.Call
}

// DeleteProject is a helper method to define mock.On call
//   - id int
func (_e *Repository_Expecter) DeleteProject(id interface{}) *Repository_DeleteProject_Call {
	return &Repository_DeleteProject_Call{Call: _e.mock.On("DeleteProject", id)}
}

func (_c *Repository_DeleteProject_Call) Run(run func(id int)) *Repository_DeleteProject_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(int))
	})
	return _c
}

func (_c *Repository_DeleteProject_Call) Return(_a0 error) *Repository_DeleteProject_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Repository_DeleteProject_Call) RunAndReturn(run func(int) error) *Repository_DeleteProject_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteRule provides a mock function with given fields: id
func (_m *Repository) DeleteRule(id int) error {
	ret := _m.Called(id)

	if len(ret) == 0 {
		panic("no return value specified for DeleteRule")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(int) error); ok {
		r0 = rf(id)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Repository_DeleteRule_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteRule'
type Repository_DeleteRule_Call struct {
	*mock.Call
}

// DeleteRule is a helper method to define mock.On call
//   - id int
func (_e *Repository_Expecter) DeleteRule(id interface{}) *Repository_DeleteRule_Call {
	return &Repository_DeleteRule_Call{Call: _e.mock.On("DeleteRule", id)}
}

func (_c *Repository_DeleteRule_Call) Run(run func(id int)) *Repository_DeleteRule_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(int))
	})
	return _c
}

func (_c *Repository_DeleteRule_Call) Return(_a0 error) *Repository_DeleteRule_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Repository_DeleteRule_Call) RunAndReturn(run func(int) error) *Repository_DeleteRule_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteToken provides a mock function with given fields: tokenID
func (_m *Repository) DeleteToken(tokenID int) error {
	ret := _m.Called(tokenID)

	if len(ret) == 0 {
		panic("no return value specified for DeleteToken")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(int) error); ok {
		r0 = rf(tokenID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Repository_DeleteToken_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteToken'
type Repository_DeleteToken_Call struct {
	*mock.Call
}

// DeleteToken is a helper method to define mock.On call
//   - tokenID int
func (_e *Repository_Expecter) DeleteToken(tokenID interface{}) *Repository_DeleteToken_Call {
	return &Repository_DeleteToken_Call{Call: _e.mock.On("DeleteToken", tokenID)}
}

func (_c *Repository_DeleteToken_Call) Run(run func(tokenID int)) *Repository_DeleteToken_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(int))
	})
	return _c
}

func (_c *Repository_DeleteToken_Call) Return(_a0 error) *Repository_DeleteToken_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Repository_DeleteToken_Call) RunAndReturn(run func(int) error) *Repository_DeleteToken_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteUser provides a mock function with given fields: userId
func (_m *Repository) DeleteUser(userId int) error {
	ret := _m.Called(userId)

	if len(ret) == 0 {
		panic("no return value specified for DeleteUser")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(int) error); ok {
		r0 = rf(userId)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Repository_DeleteUser_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteUser'
type Repository_DeleteUser_Call struct {
	*mock.Call
}

// DeleteUser is a helper method to define mock.On call
//   - userId int
func (_e *Repository_Expecter) DeleteUser(userId interface{}) *Repository_DeleteUser_Call {
	return &Repository_DeleteUser_Call{Call: _e.mock.On("DeleteUser", userId)}
}

func (_c *Repository_DeleteUser_Call) Run(run func(userId int)) *Repository_DeleteUser_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(int))
	})
	return _c
}

func (_c *Repository_DeleteUser_Call) Return(_a0 error) *Repository_DeleteUser_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Repository_DeleteUser_Call) RunAndReturn(run func(int) error) *Repository_DeleteUser_Call {
	_c.Call.Return(run)
	return _c
}

// GetInbox provides a mock function with given fields: id
func (_m *Repository) GetInbox(id int) (models.Inbox, error) {
	ret := _m.Called(id)

	if len(ret) == 0 {
		panic("no return value specified for GetInbox")
	}

	var r0 models.Inbox
	var r1 error
	if rf, ok := ret.Get(0).(func(int) (models.Inbox, error)); ok {
		return rf(id)
	}
	if rf, ok := ret.Get(0).(func(int) models.Inbox); ok {
		r0 = rf(id)
	} else {
		r0 = ret.Get(0).(models.Inbox)
	}

	if rf, ok := ret.Get(1).(func(int) error); ok {
		r1 = rf(id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Repository_GetInbox_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetInbox'
type Repository_GetInbox_Call struct {
	*mock.Call
}

// GetInbox is a helper method to define mock.On call
//   - id int
func (_e *Repository_Expecter) GetInbox(id interface{}) *Repository_GetInbox_Call {
	return &Repository_GetInbox_Call{Call: _e.mock.On("GetInbox", id)}
}

func (_c *Repository_GetInbox_Call) Run(run func(id int)) *Repository_GetInbox_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(int))
	})
	return _c
}

func (_c *Repository_GetInbox_Call) Return(_a0 models.Inbox, _a1 error) *Repository_GetInbox_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Repository_GetInbox_Call) RunAndReturn(run func(int) (models.Inbox, error)) *Repository_GetInbox_Call {
	_c.Call.Return(run)
	return _c
}

// GetInboxByEmail provides a mock function with given fields: email
func (_m *Repository) GetInboxByEmail(email string) (models.Inbox, error) {
	ret := _m.Called(email)

	if len(ret) == 0 {
		panic("no return value specified for GetInboxByEmail")
	}

	var r0 models.Inbox
	var r1 error
	if rf, ok := ret.Get(0).(func(string) (models.Inbox, error)); ok {
		return rf(email)
	}
	if rf, ok := ret.Get(0).(func(string) models.Inbox); ok {
		r0 = rf(email)
	} else {
		r0 = ret.Get(0).(models.Inbox)
	}

	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(email)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Repository_GetInboxByEmail_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetInboxByEmail'
type Repository_GetInboxByEmail_Call struct {
	*mock.Call
}

// GetInboxByEmail is a helper method to define mock.On call
//   - email string
func (_e *Repository_Expecter) GetInboxByEmail(email interface{}) *Repository_GetInboxByEmail_Call {
	return &Repository_GetInboxByEmail_Call{Call: _e.mock.On("GetInboxByEmail", email)}
}

func (_c *Repository_GetInboxByEmail_Call) Run(run func(email string)) *Repository_GetInboxByEmail_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *Repository_GetInboxByEmail_Call) Return(_a0 models.Inbox, _a1 error) *Repository_GetInboxByEmail_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Repository_GetInboxByEmail_Call) RunAndReturn(run func(string) (models.Inbox, error)) *Repository_GetInboxByEmail_Call {
	_c.Call.Return(run)
	return _c
}

// GetMessage provides a mock function with given fields: id
func (_m *Repository) GetMessage(id int) (models.Message, error) {
	ret := _m.Called(id)

	if len(ret) == 0 {
		panic("no return value specified for GetMessage")
	}

	var r0 models.Message
	var r1 error
	if rf, ok := ret.Get(0).(func(int) (models.Message, error)); ok {
		return rf(id)
	}
	if rf, ok := ret.Get(0).(func(int) models.Message); ok {
		r0 = rf(id)
	} else {
		r0 = ret.Get(0).(models.Message)
	}

	if rf, ok := ret.Get(1).(func(int) error); ok {
		r1 = rf(id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Repository_GetMessage_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetMessage'
type Repository_GetMessage_Call struct {
	*mock.Call
}

// GetMessage is a helper method to define mock.On call
//   - id int
func (_e *Repository_Expecter) GetMessage(id interface{}) *Repository_GetMessage_Call {
	return &Repository_GetMessage_Call{Call: _e.mock.On("GetMessage", id)}
}

func (_c *Repository_GetMessage_Call) Run(run func(id int)) *Repository_GetMessage_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(int))
	})
	return _c
}

func (_c *Repository_GetMessage_Call) Return(_a0 models.Message, _a1 error) *Repository_GetMessage_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Repository_GetMessage_Call) RunAndReturn(run func(int) (models.Message, error)) *Repository_GetMessage_Call {
	_c.Call.Return(run)
	return _c
}

// GetProject provides a mock function with given fields: id
func (_m *Repository) GetProject(id int) (models.Project, error) {
	ret := _m.Called(id)

	if len(ret) == 0 {
		panic("no return value specified for GetProject")
	}

	var r0 models.Project
	var r1 error
	if rf, ok := ret.Get(0).(func(int) (models.Project, error)); ok {
		return rf(id)
	}
	if rf, ok := ret.Get(0).(func(int) models.Project); ok {
		r0 = rf(id)
	} else {
		r0 = ret.Get(0).(models.Project)
	}

	if rf, ok := ret.Get(1).(func(int) error); ok {
		r1 = rf(id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Repository_GetProject_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetProject'
type Repository_GetProject_Call struct {
	*mock.Call
}

// GetProject is a helper method to define mock.On call
//   - id int
func (_e *Repository_Expecter) GetProject(id interface{}) *Repository_GetProject_Call {
	return &Repository_GetProject_Call{Call: _e.mock.On("GetProject", id)}
}

func (_c *Repository_GetProject_Call) Run(run func(id int)) *Repository_GetProject_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(int))
	})
	return _c
}

func (_c *Repository_GetProject_Call) Return(_a0 models.Project, _a1 error) *Repository_GetProject_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Repository_GetProject_Call) RunAndReturn(run func(int) (models.Project, error)) *Repository_GetProject_Call {
	_c.Call.Return(run)
	return _c
}

// GetProjectUser provides a mock function with given fields: projectId, userId
func (_m *Repository) GetProjectUser(projectId int, userId int) (models.ProjectUser, error) {
	ret := _m.Called(projectId, userId)

	if len(ret) == 0 {
		panic("no return value specified for GetProjectUser")
	}

	var r0 models.ProjectUser
	var r1 error
	if rf, ok := ret.Get(0).(func(int, int) (models.ProjectUser, error)); ok {
		return rf(projectId, userId)
	}
	if rf, ok := ret.Get(0).(func(int, int) models.ProjectUser); ok {
		r0 = rf(projectId, userId)
	} else {
		r0 = ret.Get(0).(models.ProjectUser)
	}

	if rf, ok := ret.Get(1).(func(int, int) error); ok {
		r1 = rf(projectId, userId)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Repository_GetProjectUser_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetProjectUser'
type Repository_GetProjectUser_Call struct {
	*mock.Call
}

// GetProjectUser is a helper method to define mock.On call
//   - projectId int
//   - userId int
func (_e *Repository_Expecter) GetProjectUser(projectId interface{}, userId interface{}) *Repository_GetProjectUser_Call {
	return &Repository_GetProjectUser_Call{Call: _e.mock.On("GetProjectUser", projectId, userId)}
}

func (_c *Repository_GetProjectUser_Call) Run(run func(projectId int, userId int)) *Repository_GetProjectUser_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(int), args[1].(int))
	})
	return _c
}

func (_c *Repository_GetProjectUser_Call) Return(_a0 models.ProjectUser, _a1 error) *Repository_GetProjectUser_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Repository_GetProjectUser_Call) RunAndReturn(run func(int, int) (models.ProjectUser, error)) *Repository_GetProjectUser_Call {
	_c.Call.Return(run)
	return _c
}

// GetRule provides a mock function with given fields: id
func (_m *Repository) GetRule(id int) (models.ForwardRule, error) {
	ret := _m.Called(id)

	if len(ret) == 0 {
		panic("no return value specified for GetRule")
	}

	var r0 models.ForwardRule
	var r1 error
	if rf, ok := ret.Get(0).(func(int) (models.ForwardRule, error)); ok {
		return rf(id)
	}
	if rf, ok := ret.Get(0).(func(int) models.ForwardRule); ok {
		r0 = rf(id)
	} else {
		r0 = ret.Get(0).(models.ForwardRule)
	}

	if rf, ok := ret.Get(1).(func(int) error); ok {
		r1 = rf(id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Repository_GetRule_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetRule'
type Repository_GetRule_Call struct {
	*mock.Call
}

// GetRule is a helper method to define mock.On call
//   - id int
func (_e *Repository_Expecter) GetRule(id interface{}) *Repository_GetRule_Call {
	return &Repository_GetRule_Call{Call: _e.mock.On("GetRule", id)}
}

func (_c *Repository_GetRule_Call) Run(run func(id int)) *Repository_GetRule_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(int))
	})
	return _c
}

func (_c *Repository_GetRule_Call) Return(_a0 models.ForwardRule, _a1 error) *Repository_GetRule_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Repository_GetRule_Call) RunAndReturn(run func(int) (models.ForwardRule, error)) *Repository_GetRule_Call {
	_c.Call.Return(run)
	return _c
}

// GetTokenByUser provides a mock function with given fields: userID, tokenID
func (_m *Repository) GetTokenByUser(userID int, tokenID int) (models.Token, error) {
	ret := _m.Called(userID, tokenID)

	if len(ret) == 0 {
		panic("no return value specified for GetTokenByUser")
	}

	var r0 models.Token
	var r1 error
	if rf, ok := ret.Get(0).(func(int, int) (models.Token, error)); ok {
		return rf(userID, tokenID)
	}
	if rf, ok := ret.Get(0).(func(int, int) models.Token); ok {
		r0 = rf(userID, tokenID)
	} else {
		r0 = ret.Get(0).(models.Token)
	}

	if rf, ok := ret.Get(1).(func(int, int) error); ok {
		r1 = rf(userID, tokenID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Repository_GetTokenByUser_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetTokenByUser'
type Repository_GetTokenByUser_Call struct {
	*mock.Call
}

// GetTokenByUser is a helper method to define mock.On call
//   - userID int
//   - tokenID int
func (_e *Repository_Expecter) GetTokenByUser(userID interface{}, tokenID interface{}) *Repository_GetTokenByUser_Call {
	return &Repository_GetTokenByUser_Call{Call: _e.mock.On("GetTokenByUser", userID, tokenID)}
}

func (_c *Repository_GetTokenByUser_Call) Run(run func(userID int, tokenID int)) *Repository_GetTokenByUser_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(int), args[1].(int))
	})
	return _c
}

func (_c *Repository_GetTokenByUser_Call) Return(_a0 models.Token, _a1 error) *Repository_GetTokenByUser_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Repository_GetTokenByUser_Call) RunAndReturn(run func(int, int) (models.Token, error)) *Repository_GetTokenByUser_Call {
	_c.Call.Return(run)
	return _c
}

// GetUser provides a mock function with given fields: id
func (_m *Repository) GetUser(id int) (models.User, error) {
	ret := _m.Called(id)

	if len(ret) == 0 {
		panic("no return value specified for GetUser")
	}

	var r0 models.User
	var r1 error
	if rf, ok := ret.Get(0).(func(int) (models.User, error)); ok {
		return rf(id)
	}
	if rf, ok := ret.Get(0).(func(int) models.User); ok {
		r0 = rf(id)
	} else {
		r0 = ret.Get(0).(models.User)
	}

	if rf, ok := ret.Get(1).(func(int) error); ok {
		r1 = rf(id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Repository_GetUser_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetUser'
type Repository_GetUser_Call struct {
	*mock.Call
}

// GetUser is a helper method to define mock.On call
//   - id int
func (_e *Repository_Expecter) GetUser(id interface{}) *Repository_GetUser_Call {
	return &Repository_GetUser_Call{Call: _e.mock.On("GetUser", id)}
}

func (_c *Repository_GetUser_Call) Run(run func(id int)) *Repository_GetUser_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(int))
	})
	return _c
}

func (_c *Repository_GetUser_Call) Return(_a0 models.User, _a1 error) *Repository_GetUser_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Repository_GetUser_Call) RunAndReturn(run func(int) (models.User, error)) *Repository_GetUser_Call {
	_c.Call.Return(run)
	return _c
}

// GetUserByUsername provides a mock function with given fields: username
func (_m *Repository) GetUserByUsername(username string) (models.User, error) {
	ret := _m.Called(username)

	if len(ret) == 0 {
		panic("no return value specified for GetUserByUsername")
	}

	var r0 models.User
	var r1 error
	if rf, ok := ret.Get(0).(func(string) (models.User, error)); ok {
		return rf(username)
	}
	if rf, ok := ret.Get(0).(func(string) models.User); ok {
		r0 = rf(username)
	} else {
		r0 = ret.Get(0).(models.User)
	}

	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(username)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Repository_GetUserByUsername_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetUserByUsername'
type Repository_GetUserByUsername_Call struct {
	*mock.Call
}

// GetUserByUsername is a helper method to define mock.On call
//   - username string
func (_e *Repository_Expecter) GetUserByUsername(username interface{}) *Repository_GetUserByUsername_Call {
	return &Repository_GetUserByUsername_Call{Call: _e.mock.On("GetUserByUsername", username)}
}

func (_c *Repository_GetUserByUsername_Call) Run(run func(username string)) *Repository_GetUserByUsername_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *Repository_GetUserByUsername_Call) Return(_a0 models.User, _a1 error) *Repository_GetUserByUsername_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Repository_GetUserByUsername_Call) RunAndReturn(run func(string) (models.User, error)) *Repository_GetUserByUsername_Call {
	_c.Call.Return(run)
	return _c
}

// ListInboxesByProject provides a mock function with given fields: projectID, limit, offset
func (_m *Repository) ListInboxesByProject(projectID int, limit int, offset int) ([]models.Inbox, int, error) {
	ret := _m.Called(projectID, limit, offset)

	if len(ret) == 0 {
		panic("no return value specified for ListInboxesByProject")
	}

	var r0 []models.Inbox
	var r1 int
	var r2 error
	if rf, ok := ret.Get(0).(func(int, int, int) ([]models.Inbox, int, error)); ok {
		return rf(projectID, limit, offset)
	}
	if rf, ok := ret.Get(0).(func(int, int, int) []models.Inbox); ok {
		r0 = rf(projectID, limit, offset)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]models.Inbox)
		}
	}

	if rf, ok := ret.Get(1).(func(int, int, int) int); ok {
		r1 = rf(projectID, limit, offset)
	} else {
		r1 = ret.Get(1).(int)
	}

	if rf, ok := ret.Get(2).(func(int, int, int) error); ok {
		r2 = rf(projectID, limit, offset)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// Repository_ListInboxesByProject_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListInboxesByProject'
type Repository_ListInboxesByProject_Call struct {
	*mock.Call
}

// ListInboxesByProject is a helper method to define mock.On call
//   - projectID int
//   - limit int
//   - offset int
func (_e *Repository_Expecter) ListInboxesByProject(projectID interface{}, limit interface{}, offset interface{}) *Repository_ListInboxesByProject_Call {
	return &Repository_ListInboxesByProject_Call{Call: _e.mock.On("ListInboxesByProject", projectID, limit, offset)}
}

func (_c *Repository_ListInboxesByProject_Call) Run(run func(projectID int, limit int, offset int)) *Repository_ListInboxesByProject_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(int), args[1].(int), args[2].(int))
	})
	return _c
}

func (_c *Repository_ListInboxesByProject_Call) Return(_a0 []models.Inbox, _a1 int, _a2 error) *Repository_ListInboxesByProject_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *Repository_ListInboxesByProject_Call) RunAndReturn(run func(int, int, int) ([]models.Inbox, int, error)) *Repository_ListInboxesByProject_Call {
	_c.Call.Return(run)
	return _c
}

// ListMessagesByInbox provides a mock function with given fields: inboxID, limit, offset
func (_m *Repository) ListMessagesByInbox(inboxID int, limit int, offset int) ([]models.Message, int, error) {
	ret := _m.Called(inboxID, limit, offset)

	if len(ret) == 0 {
		panic("no return value specified for ListMessagesByInbox")
	}

	var r0 []models.Message
	var r1 int
	var r2 error
	if rf, ok := ret.Get(0).(func(int, int, int) ([]models.Message, int, error)); ok {
		return rf(inboxID, limit, offset)
	}
	if rf, ok := ret.Get(0).(func(int, int, int) []models.Message); ok {
		r0 = rf(inboxID, limit, offset)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]models.Message)
		}
	}

	if rf, ok := ret.Get(1).(func(int, int, int) int); ok {
		r1 = rf(inboxID, limit, offset)
	} else {
		r1 = ret.Get(1).(int)
	}

	if rf, ok := ret.Get(2).(func(int, int, int) error); ok {
		r2 = rf(inboxID, limit, offset)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// Repository_ListMessagesByInbox_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListMessagesByInbox'
type Repository_ListMessagesByInbox_Call struct {
	*mock.Call
}

// ListMessagesByInbox is a helper method to define mock.On call
//   - inboxID int
//   - limit int
//   - offset int
func (_e *Repository_Expecter) ListMessagesByInbox(inboxID interface{}, limit interface{}, offset interface{}) *Repository_ListMessagesByInbox_Call {
	return &Repository_ListMessagesByInbox_Call{Call: _e.mock.On("ListMessagesByInbox", inboxID, limit, offset)}
}

func (_c *Repository_ListMessagesByInbox_Call) Run(run func(inboxID int, limit int, offset int)) *Repository_ListMessagesByInbox_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(int), args[1].(int), args[2].(int))
	})
	return _c
}

func (_c *Repository_ListMessagesByInbox_Call) Return(_a0 []models.Message, _a1 int, _a2 error) *Repository_ListMessagesByInbox_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *Repository_ListMessagesByInbox_Call) RunAndReturn(run func(int, int, int) ([]models.Message, int, error)) *Repository_ListMessagesByInbox_Call {
	_c.Call.Return(run)
	return _c
}

// ListMessagesByInboxWithFilter provides a mock function with given fields: inboxID, isRead, limit, offset
func (_m *Repository) ListMessagesByInboxWithFilter(inboxID int, isRead *bool, limit int, offset int) ([]models.Message, int, error) {
	ret := _m.Called(inboxID, isRead, limit, offset)

	if len(ret) == 0 {
		panic("no return value specified for ListMessagesByInboxWithFilter")
	}

	var r0 []models.Message
	var r1 int
	var r2 error
	if rf, ok := ret.Get(0).(func(int, *bool, int, int) ([]models.Message, int, error)); ok {
		return rf(inboxID, isRead, limit, offset)
	}
	if rf, ok := ret.Get(0).(func(int, *bool, int, int) []models.Message); ok {
		r0 = rf(inboxID, isRead, limit, offset)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]models.Message)
		}
	}

	if rf, ok := ret.Get(1).(func(int, *bool, int, int) int); ok {
		r1 = rf(inboxID, isRead, limit, offset)
	} else {
		r1 = ret.Get(1).(int)
	}

	if rf, ok := ret.Get(2).(func(int, *bool, int, int) error); ok {
		r2 = rf(inboxID, isRead, limit, offset)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// Repository_ListMessagesByInboxWithFilter_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListMessagesByInboxWithFilter'
type Repository_ListMessagesByInboxWithFilter_Call struct {
	*mock.Call
}

// ListMessagesByInboxWithFilter is a helper method to define mock.On call
//   - inboxID int
//   - isRead *bool
//   - limit int
//   - offset int
func (_e *Repository_Expecter) ListMessagesByInboxWithFilter(inboxID interface{}, isRead interface{}, limit interface{}, offset interface{}) *Repository_ListMessagesByInboxWithFilter_Call {
	return &Repository_ListMessagesByInboxWithFilter_Call{Call: _e.mock.On("ListMessagesByInboxWithFilter", inboxID, isRead, limit, offset)}
}

func (_c *Repository_ListMessagesByInboxWithFilter_Call) Run(run func(inboxID int, isRead *bool, limit int, offset int)) *Repository_ListMessagesByInboxWithFilter_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(int), args[1].(*bool), args[2].(int), args[3].(int))
	})
	return _c
}

func (_c *Repository_ListMessagesByInboxWithFilter_Call) Return(_a0 []models.Message, _a1 int, _a2 error) *Repository_ListMessagesByInboxWithFilter_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *Repository_ListMessagesByInboxWithFilter_Call) RunAndReturn(run func(int, *bool, int, int) ([]models.Message, int, error)) *Repository_ListMessagesByInboxWithFilter_Call {
	_c.Call.Return(run)
	return _c
}

// ListProjects provides a mock function with given fields: limit, offset
func (_m *Repository) ListProjects(limit int, offset int) ([]models.Project, int, error) {
	ret := _m.Called(limit, offset)

	if len(ret) == 0 {
		panic("no return value specified for ListProjects")
	}

	var r0 []models.Project
	var r1 int
	var r2 error
	if rf, ok := ret.Get(0).(func(int, int) ([]models.Project, int, error)); ok {
		return rf(limit, offset)
	}
	if rf, ok := ret.Get(0).(func(int, int) []models.Project); ok {
		r0 = rf(limit, offset)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]models.Project)
		}
	}

	if rf, ok := ret.Get(1).(func(int, int) int); ok {
		r1 = rf(limit, offset)
	} else {
		r1 = ret.Get(1).(int)
	}

	if rf, ok := ret.Get(2).(func(int, int) error); ok {
		r2 = rf(limit, offset)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// Repository_ListProjects_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListProjects'
type Repository_ListProjects_Call struct {
	*mock.Call
}

// ListProjects is a helper method to define mock.On call
//   - limit int
//   - offset int
func (_e *Repository_Expecter) ListProjects(limit interface{}, offset interface{}) *Repository_ListProjects_Call {
	return &Repository_ListProjects_Call{Call: _e.mock.On("ListProjects", limit, offset)}
}

func (_c *Repository_ListProjects_Call) Run(run func(limit int, offset int)) *Repository_ListProjects_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(int), args[1].(int))
	})
	return _c
}

func (_c *Repository_ListProjects_Call) Return(_a0 []models.Project, _a1 int, _a2 error) *Repository_ListProjects_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *Repository_ListProjects_Call) RunAndReturn(run func(int, int) ([]models.Project, int, error)) *Repository_ListProjects_Call {
	_c.Call.Return(run)
	return _c
}

// ListProjectsByUser provides a mock function with given fields: userID, limit, offset
func (_m *Repository) ListProjectsByUser(userID int, limit int, offset int) ([]models.Project, int, error) {
	ret := _m.Called(userID, limit, offset)

	if len(ret) == 0 {
		panic("no return value specified for ListProjectsByUser")
	}

	var r0 []models.Project
	var r1 int
	var r2 error
	if rf, ok := ret.Get(0).(func(int, int, int) ([]models.Project, int, error)); ok {
		return rf(userID, limit, offset)
	}
	if rf, ok := ret.Get(0).(func(int, int, int) []models.Project); ok {
		r0 = rf(userID, limit, offset)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]models.Project)
		}
	}

	if rf, ok := ret.Get(1).(func(int, int, int) int); ok {
		r1 = rf(userID, limit, offset)
	} else {
		r1 = ret.Get(1).(int)
	}

	if rf, ok := ret.Get(2).(func(int, int, int) error); ok {
		r2 = rf(userID, limit, offset)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// Repository_ListProjectsByUser_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListProjectsByUser'
type Repository_ListProjectsByUser_Call struct {
	*mock.Call
}

// ListProjectsByUser is a helper method to define mock.On call
//   - userID int
//   - limit int
//   - offset int
func (_e *Repository_Expecter) ListProjectsByUser(userID interface{}, limit interface{}, offset interface{}) *Repository_ListProjectsByUser_Call {
	return &Repository_ListProjectsByUser_Call{Call: _e.mock.On("ListProjectsByUser", userID, limit, offset)}
}

func (_c *Repository_ListProjectsByUser_Call) Run(run func(userID int, limit int, offset int)) *Repository_ListProjectsByUser_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(int), args[1].(int), args[2].(int))
	})
	return _c
}

func (_c *Repository_ListProjectsByUser_Call) Return(_a0 []models.Project, _a1 int, _a2 error) *Repository_ListProjectsByUser_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *Repository_ListProjectsByUser_Call) RunAndReturn(run func(int, int, int) ([]models.Project, int, error)) *Repository_ListProjectsByUser_Call {
	_c.Call.Return(run)
	return _c
}

// ListRules provides a mock function with given fields: limit, offset
func (_m *Repository) ListRules(limit int, offset int) ([]models.ForwardRule, int, error) {
	ret := _m.Called(limit, offset)

	if len(ret) == 0 {
		panic("no return value specified for ListRules")
	}

	var r0 []models.ForwardRule
	var r1 int
	var r2 error
	if rf, ok := ret.Get(0).(func(int, int) ([]models.ForwardRule, int, error)); ok {
		return rf(limit, offset)
	}
	if rf, ok := ret.Get(0).(func(int, int) []models.ForwardRule); ok {
		r0 = rf(limit, offset)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]models.ForwardRule)
		}
	}

	if rf, ok := ret.Get(1).(func(int, int) int); ok {
		r1 = rf(limit, offset)
	} else {
		r1 = ret.Get(1).(int)
	}

	if rf, ok := ret.Get(2).(func(int, int) error); ok {
		r2 = rf(limit, offset)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// Repository_ListRules_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListRules'
type Repository_ListRules_Call struct {
	*mock.Call
}

// ListRules is a helper method to define mock.On call
//   - limit int
//   - offset int
func (_e *Repository_Expecter) ListRules(limit interface{}, offset interface{}) *Repository_ListRules_Call {
	return &Repository_ListRules_Call{Call: _e.mock.On("ListRules", limit, offset)}
}

func (_c *Repository_ListRules_Call) Run(run func(limit int, offset int)) *Repository_ListRules_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(int), args[1].(int))
	})
	return _c
}

func (_c *Repository_ListRules_Call) Return(_a0 []models.ForwardRule, _a1 int, _a2 error) *Repository_ListRules_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *Repository_ListRules_Call) RunAndReturn(run func(int, int) ([]models.ForwardRule, int, error)) *Repository_ListRules_Call {
	_c.Call.Return(run)
	return _c
}

// ListRulesByInbox provides a mock function with given fields: inboxID, limit, offset
func (_m *Repository) ListRulesByInbox(inboxID int, limit int, offset int) ([]models.ForwardRule, int, error) {
	ret := _m.Called(inboxID, limit, offset)

	if len(ret) == 0 {
		panic("no return value specified for ListRulesByInbox")
	}

	var r0 []models.ForwardRule
	var r1 int
	var r2 error
	if rf, ok := ret.Get(0).(func(int, int, int) ([]models.ForwardRule, int, error)); ok {
		return rf(inboxID, limit, offset)
	}
	if rf, ok := ret.Get(0).(func(int, int, int) []models.ForwardRule); ok {
		r0 = rf(inboxID, limit, offset)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]models.ForwardRule)
		}
	}

	if rf, ok := ret.Get(1).(func(int, int, int) int); ok {
		r1 = rf(inboxID, limit, offset)
	} else {
		r1 = ret.Get(1).(int)
	}

	if rf, ok := ret.Get(2).(func(int, int, int) error); ok {
		r2 = rf(inboxID, limit, offset)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// Repository_ListRulesByInbox_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListRulesByInbox'
type Repository_ListRulesByInbox_Call struct {
	*mock.Call
}

// ListRulesByInbox is a helper method to define mock.On call
//   - inboxID int
//   - limit int
//   - offset int
func (_e *Repository_Expecter) ListRulesByInbox(inboxID interface{}, limit interface{}, offset interface{}) *Repository_ListRulesByInbox_Call {
	return &Repository_ListRulesByInbox_Call{Call: _e.mock.On("ListRulesByInbox", inboxID, limit, offset)}
}

func (_c *Repository_ListRulesByInbox_Call) Run(run func(inboxID int, limit int, offset int)) *Repository_ListRulesByInbox_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(int), args[1].(int), args[2].(int))
	})
	return _c
}

func (_c *Repository_ListRulesByInbox_Call) Return(_a0 []models.ForwardRule, _a1 int, _a2 error) *Repository_ListRulesByInbox_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *Repository_ListRulesByInbox_Call) RunAndReturn(run func(int, int, int) ([]models.ForwardRule, int, error)) *Repository_ListRulesByInbox_Call {
	_c.Call.Return(run)
	return _c
}

// ListTokensByUser provides a mock function with given fields: userID, limit, offset
func (_m *Repository) ListTokensByUser(userID int, limit int, offset int) ([]models.Token, int, error) {
	ret := _m.Called(userID, limit, offset)

	if len(ret) == 0 {
		panic("no return value specified for ListTokensByUser")
	}

	var r0 []models.Token
	var r1 int
	var r2 error
	if rf, ok := ret.Get(0).(func(int, int, int) ([]models.Token, int, error)); ok {
		return rf(userID, limit, offset)
	}
	if rf, ok := ret.Get(0).(func(int, int, int) []models.Token); ok {
		r0 = rf(userID, limit, offset)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]models.Token)
		}
	}

	if rf, ok := ret.Get(1).(func(int, int, int) int); ok {
		r1 = rf(userID, limit, offset)
	} else {
		r1 = ret.Get(1).(int)
	}

	if rf, ok := ret.Get(2).(func(int, int, int) error); ok {
		r2 = rf(userID, limit, offset)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// Repository_ListTokensByUser_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListTokensByUser'
type Repository_ListTokensByUser_Call struct {
	*mock.Call
}

// ListTokensByUser is a helper method to define mock.On call
//   - userID int
//   - limit int
//   - offset int
func (_e *Repository_Expecter) ListTokensByUser(userID interface{}, limit interface{}, offset interface{}) *Repository_ListTokensByUser_Call {
	return &Repository_ListTokensByUser_Call{Call: _e.mock.On("ListTokensByUser", userID, limit, offset)}
}

func (_c *Repository_ListTokensByUser_Call) Run(run func(userID int, limit int, offset int)) *Repository_ListTokensByUser_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(int), args[1].(int), args[2].(int))
	})
	return _c
}

func (_c *Repository_ListTokensByUser_Call) Return(_a0 []models.Token, _a1 int, _a2 error) *Repository_ListTokensByUser_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *Repository_ListTokensByUser_Call) RunAndReturn(run func(int, int, int) ([]models.Token, int, error)) *Repository_ListTokensByUser_Call {
	_c.Call.Return(run)
	return _c
}

// ListUsers provides a mock function with given fields: limit, offset
func (_m *Repository) ListUsers(limit int, offset int) ([]models.User, int, error) {
	ret := _m.Called(limit, offset)

	if len(ret) == 0 {
		panic("no return value specified for ListUsers")
	}

	var r0 []models.User
	var r1 int
	var r2 error
	if rf, ok := ret.Get(0).(func(int, int) ([]models.User, int, error)); ok {
		return rf(limit, offset)
	}
	if rf, ok := ret.Get(0).(func(int, int) []models.User); ok {
		r0 = rf(limit, offset)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]models.User)
		}
	}

	if rf, ok := ret.Get(1).(func(int, int) int); ok {
		r1 = rf(limit, offset)
	} else {
		r1 = ret.Get(1).(int)
	}

	if rf, ok := ret.Get(2).(func(int, int) error); ok {
		r2 = rf(limit, offset)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// Repository_ListUsers_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListUsers'
type Repository_ListUsers_Call struct {
	*mock.Call
}

// ListUsers is a helper method to define mock.On call
//   - limit int
//   - offset int
func (_e *Repository_Expecter) ListUsers(limit interface{}, offset interface{}) *Repository_ListUsers_Call {
	return &Repository_ListUsers_Call{Call: _e.mock.On("ListUsers", limit, offset)}
}

func (_c *Repository_ListUsers_Call) Run(run func(limit int, offset int)) *Repository_ListUsers_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(int), args[1].(int))
	})
	return _c
}

func (_c *Repository_ListUsers_Call) Return(_a0 []models.User, _a1 int, _a2 error) *Repository_ListUsers_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *Repository_ListUsers_Call) RunAndReturn(run func(int, int) ([]models.User, int, error)) *Repository_ListUsers_Call {
	_c.Call.Return(run)
	return _c
}

// ProjectAddUser provides a mock function with given fields: projectUser
func (_m *Repository) ProjectAddUser(projectUser models.ProjectUser) (models.ProjectUser, error) {
	ret := _m.Called(projectUser)

	if len(ret) == 0 {
		panic("no return value specified for ProjectAddUser")
	}

	var r0 models.ProjectUser
	var r1 error
	if rf, ok := ret.Get(0).(func(models.ProjectUser) (models.ProjectUser, error)); ok {
		return rf(projectUser)
	}
	if rf, ok := ret.Get(0).(func(models.ProjectUser) models.ProjectUser); ok {
		r0 = rf(projectUser)
	} else {
		r0 = ret.Get(0).(models.ProjectUser)
	}

	if rf, ok := ret.Get(1).(func(models.ProjectUser) error); ok {
		r1 = rf(projectUser)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Repository_ProjectAddUser_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ProjectAddUser'
type Repository_ProjectAddUser_Call struct {
	*mock.Call
}

// ProjectAddUser is a helper method to define mock.On call
//   - projectUser models.ProjectUser
func (_e *Repository_Expecter) ProjectAddUser(projectUser interface{}) *Repository_ProjectAddUser_Call {
	return &Repository_ProjectAddUser_Call{Call: _e.mock.On("ProjectAddUser", projectUser)}
}

func (_c *Repository_ProjectAddUser_Call) Run(run func(projectUser models.ProjectUser)) *Repository_ProjectAddUser_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(models.ProjectUser))
	})
	return _c
}

func (_c *Repository_ProjectAddUser_Call) Return(_a0 models.ProjectUser, _a1 error) *Repository_ProjectAddUser_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Repository_ProjectAddUser_Call) RunAndReturn(run func(models.ProjectUser) (models.ProjectUser, error)) *Repository_ProjectAddUser_Call {
	_c.Call.Return(run)
	return _c
}

// ProjectRemoveUser provides a mock function with given fields: projectID, userID
func (_m *Repository) ProjectRemoveUser(projectID int, userID int) error {
	ret := _m.Called(projectID, userID)

	if len(ret) == 0 {
		panic("no return value specified for ProjectRemoveUser")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(int, int) error); ok {
		r0 = rf(projectID, userID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Repository_ProjectRemoveUser_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ProjectRemoveUser'
type Repository_ProjectRemoveUser_Call struct {
	*mock.Call
}

// ProjectRemoveUser is a helper method to define mock.On call
//   - projectID int
//   - userID int
func (_e *Repository_Expecter) ProjectRemoveUser(projectID interface{}, userID interface{}) *Repository_ProjectRemoveUser_Call {
	return &Repository_ProjectRemoveUser_Call{Call: _e.mock.On("ProjectRemoveUser", projectID, userID)}
}

func (_c *Repository_ProjectRemoveUser_Call) Run(run func(projectID int, userID int)) *Repository_ProjectRemoveUser_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(int), args[1].(int))
	})
	return _c
}

func (_c *Repository_ProjectRemoveUser_Call) Return(_a0 error) *Repository_ProjectRemoveUser_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Repository_ProjectRemoveUser_Call) RunAndReturn(run func(int, int) error) *Repository_ProjectRemoveUser_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateInbox provides a mock function with given fields: inbox
func (_m *Repository) UpdateInbox(inbox models.Inbox) (models.Inbox, error) {
	ret := _m.Called(inbox)

	if len(ret) == 0 {
		panic("no return value specified for UpdateInbox")
	}

	var r0 models.Inbox
	var r1 error
	if rf, ok := ret.Get(0).(func(models.Inbox) (models.Inbox, error)); ok {
		return rf(inbox)
	}
	if rf, ok := ret.Get(0).(func(models.Inbox) models.Inbox); ok {
		r0 = rf(inbox)
	} else {
		r0 = ret.Get(0).(models.Inbox)
	}

	if rf, ok := ret.Get(1).(func(models.Inbox) error); ok {
		r1 = rf(inbox)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Repository_UpdateInbox_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateInbox'
type Repository_UpdateInbox_Call struct {
	*mock.Call
}

// UpdateInbox is a helper method to define mock.On call
//   - inbox models.Inbox
func (_e *Repository_Expecter) UpdateInbox(inbox interface{}) *Repository_UpdateInbox_Call {
	return &Repository_UpdateInbox_Call{Call: _e.mock.On("UpdateInbox", inbox)}
}

func (_c *Repository_UpdateInbox_Call) Run(run func(inbox models.Inbox)) *Repository_UpdateInbox_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(models.Inbox))
	})
	return _c
}

func (_c *Repository_UpdateInbox_Call) Return(_a0 models.Inbox, _a1 error) *Repository_UpdateInbox_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Repository_UpdateInbox_Call) RunAndReturn(run func(models.Inbox) (models.Inbox, error)) *Repository_UpdateInbox_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateMessageReadStatus provides a mock function with given fields: messageID, isRead
func (_m *Repository) UpdateMessageReadStatus(messageID int, isRead bool) (models.Message, error) {
	ret := _m.Called(messageID, isRead)

	if len(ret) == 0 {
		panic("no return value specified for UpdateMessageReadStatus")
	}

	var r0 models.Message
	var r1 error
	if rf, ok := ret.Get(0).(func(int, bool) (models.Message, error)); ok {
		return rf(messageID, isRead)
	}
	if rf, ok := ret.Get(0).(func(int, bool) models.Message); ok {
		r0 = rf(messageID, isRead)
	} else {
		r0 = ret.Get(0).(models.Message)
	}

	if rf, ok := ret.Get(1).(func(int, bool) error); ok {
		r1 = rf(messageID, isRead)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Repository_UpdateMessageReadStatus_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateMessageReadStatus'
type Repository_UpdateMessageReadStatus_Call struct {
	*mock.Call
}

// UpdateMessageReadStatus is a helper method to define mock.On call
//   - messageID int
//   - isRead bool
func (_e *Repository_Expecter) UpdateMessageReadStatus(messageID interface{}, isRead interface{}) *Repository_UpdateMessageReadStatus_Call {
	return &Repository_UpdateMessageReadStatus_Call{Call: _e.mock.On("UpdateMessageReadStatus", messageID, isRead)}
}

func (_c *Repository_UpdateMessageReadStatus_Call) Run(run func(messageID int, isRead bool)) *Repository_UpdateMessageReadStatus_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(int), args[1].(bool))
	})
	return _c
}

func (_c *Repository_UpdateMessageReadStatus_Call) Return(_a0 models.Message, _a1 error) *Repository_UpdateMessageReadStatus_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Repository_UpdateMessageReadStatus_Call) RunAndReturn(run func(int, bool) (models.Message, error)) *Repository_UpdateMessageReadStatus_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateProject provides a mock function with given fields: project
func (_m *Repository) UpdateProject(project models.Project) (models.Project, error) {
	ret := _m.Called(project)

	if len(ret) == 0 {
		panic("no return value specified for UpdateProject")
	}

	var r0 models.Project
	var r1 error
	if rf, ok := ret.Get(0).(func(models.Project) (models.Project, error)); ok {
		return rf(project)
	}
	if rf, ok := ret.Get(0).(func(models.Project) models.Project); ok {
		r0 = rf(project)
	} else {
		r0 = ret.Get(0).(models.Project)
	}

	if rf, ok := ret.Get(1).(func(models.Project) error); ok {
		r1 = rf(project)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Repository_UpdateProject_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateProject'
type Repository_UpdateProject_Call struct {
	*mock.Call
}

// UpdateProject is a helper method to define mock.On call
//   - project models.Project
func (_e *Repository_Expecter) UpdateProject(project interface{}) *Repository_UpdateProject_Call {
	return &Repository_UpdateProject_Call{Call: _e.mock.On("UpdateProject", project)}
}

func (_c *Repository_UpdateProject_Call) Run(run func(project models.Project)) *Repository_UpdateProject_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(models.Project))
	})
	return _c
}

func (_c *Repository_UpdateProject_Call) Return(_a0 models.Project, _a1 error) *Repository_UpdateProject_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Repository_UpdateProject_Call) RunAndReturn(run func(models.Project) (models.Project, error)) *Repository_UpdateProject_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateRule provides a mock function with given fields: rule
func (_m *Repository) UpdateRule(rule models.ForwardRule) (models.ForwardRule, error) {
	ret := _m.Called(rule)

	if len(ret) == 0 {
		panic("no return value specified for UpdateRule")
	}

	var r0 models.ForwardRule
	var r1 error
	if rf, ok := ret.Get(0).(func(models.ForwardRule) (models.ForwardRule, error)); ok {
		return rf(rule)
	}
	if rf, ok := ret.Get(0).(func(models.ForwardRule) models.ForwardRule); ok {
		r0 = rf(rule)
	} else {
		r0 = ret.Get(0).(models.ForwardRule)
	}

	if rf, ok := ret.Get(1).(func(models.ForwardRule) error); ok {
		r1 = rf(rule)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Repository_UpdateRule_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateRule'
type Repository_UpdateRule_Call struct {
	*mock.Call
}

// UpdateRule is a helper method to define mock.On call
//   - rule models.ForwardRule
func (_e *Repository_Expecter) UpdateRule(rule interface{}) *Repository_UpdateRule_Call {
	return &Repository_UpdateRule_Call{Call: _e.mock.On("UpdateRule", rule)}
}

func (_c *Repository_UpdateRule_Call) Run(run func(rule models.ForwardRule)) *Repository_UpdateRule_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(models.ForwardRule))
	})
	return _c
}

func (_c *Repository_UpdateRule_Call) Return(_a0 models.ForwardRule, _a1 error) *Repository_UpdateRule_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Repository_UpdateRule_Call) RunAndReturn(run func(models.ForwardRule) (models.ForwardRule, error)) *Repository_UpdateRule_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateUser provides a mock function with given fields: user
func (_m *Repository) UpdateUser(user models.User) (models.User, error) {
	ret := _m.Called(user)

	if len(ret) == 0 {
		panic("no return value specified for UpdateUser")
	}

	var r0 models.User
	var r1 error
	if rf, ok := ret.Get(0).(func(models.User) (models.User, error)); ok {
		return rf(user)
	}
	if rf, ok := ret.Get(0).(func(models.User) models.User); ok {
		r0 = rf(user)
	} else {
		r0 = ret.Get(0).(models.User)
	}

	if rf, ok := ret.Get(1).(func(models.User) error); ok {
		r1 = rf(user)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Repository_UpdateUser_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateUser'
type Repository_UpdateUser_Call struct {
	*mock.Call
}

// UpdateUser is a helper method to define mock.On call
//   - user models.User
func (_e *Repository_Expecter) UpdateUser(user interface{}) *Repository_UpdateUser_Call {
	return &Repository_UpdateUser_Call{Call: _e.mock.On("UpdateUser", user)}
}

func (_c *Repository_UpdateUser_Call) Run(run func(user models.User)) *Repository_UpdateUser_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(models.User))
	})
	return _c
}

func (_c *Repository_UpdateUser_Call) Return(_a0 models.User, _a1 error) *Repository_UpdateUser_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Repository_UpdateUser_Call) RunAndReturn(run func(models.User) (models.User, error)) *Repository_UpdateUser_Call {
	_c.Call.Return(run)
	return _c
}

// NewRepository creates a new instance of Repository. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewRepository(t interface {
	mock.TestingT
	Cleanup(func())
}) *Repository {
	mock := &Repository{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
