// Code generated by mockery v2.49.0. DO NOT EDIT.

package mocks

import (
	context "context"
	models "inbox451/internal/models"

	mock "github.com/stretchr/testify/mock"
)

// MockRepository is an autogenerated mock type for the Repository type
type MockRepository struct {
	mock.Mock
}

type MockRepository_Expecter struct {
	mock *mock.Mock
}

func (_m *MockRepository) EXPECT() *MockRepository_Expecter {
	return &MockRepository_Expecter{mock: &_m.Mock}
}

// CreateInbox provides a mock function with given fields: ctx, inbox
func (_m *MockRepository) CreateInbox(ctx context.Context, inbox *models.Inbox) error {
	ret := _m.Called(ctx, inbox)

	if len(ret) == 0 {
		panic("no return value specified for CreateInbox")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *models.Inbox) error); ok {
		r0 = rf(ctx, inbox)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockRepository_CreateInbox_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateInbox'
type MockRepository_CreateInbox_Call struct {
	*mock.Call
}

// CreateInbox is a helper method to define mock.On call
//   - ctx context.Context
//   - inbox *models.Inbox
func (_e *MockRepository_Expecter) CreateInbox(ctx interface{}, inbox interface{}) *MockRepository_CreateInbox_Call {
	return &MockRepository_CreateInbox_Call{Call: _e.mock.On("CreateInbox", ctx, inbox)}
}

func (_c *MockRepository_CreateInbox_Call) Run(run func(ctx context.Context, inbox *models.Inbox)) *MockRepository_CreateInbox_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*models.Inbox))
	})
	return _c
}

func (_c *MockRepository_CreateInbox_Call) Return(_a0 error) *MockRepository_CreateInbox_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockRepository_CreateInbox_Call) RunAndReturn(run func(context.Context, *models.Inbox) error) *MockRepository_CreateInbox_Call {
	_c.Call.Return(run)
	return _c
}

// CreateMessage provides a mock function with given fields: ctx, message
func (_m *MockRepository) CreateMessage(ctx context.Context, message *models.Message) error {
	ret := _m.Called(ctx, message)

	if len(ret) == 0 {
		panic("no return value specified for CreateMessage")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *models.Message) error); ok {
		r0 = rf(ctx, message)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockRepository_CreateMessage_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateMessage'
type MockRepository_CreateMessage_Call struct {
	*mock.Call
}

// CreateMessage is a helper method to define mock.On call
//   - ctx context.Context
//   - message *models.Message
func (_e *MockRepository_Expecter) CreateMessage(ctx interface{}, message interface{}) *MockRepository_CreateMessage_Call {
	return &MockRepository_CreateMessage_Call{Call: _e.mock.On("CreateMessage", ctx, message)}
}

func (_c *MockRepository_CreateMessage_Call) Run(run func(ctx context.Context, message *models.Message)) *MockRepository_CreateMessage_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*models.Message))
	})
	return _c
}

func (_c *MockRepository_CreateMessage_Call) Return(_a0 error) *MockRepository_CreateMessage_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockRepository_CreateMessage_Call) RunAndReturn(run func(context.Context, *models.Message) error) *MockRepository_CreateMessage_Call {
	_c.Call.Return(run)
	return _c
}

// CreateProject provides a mock function with given fields: ctx, project
func (_m *MockRepository) CreateProject(ctx context.Context, project *models.Project) error {
	ret := _m.Called(ctx, project)

	if len(ret) == 0 {
		panic("no return value specified for CreateProject")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *models.Project) error); ok {
		r0 = rf(ctx, project)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockRepository_CreateProject_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateProject'
type MockRepository_CreateProject_Call struct {
	*mock.Call
}

// CreateProject is a helper method to define mock.On call
//   - ctx context.Context
//   - project *models.Project
func (_e *MockRepository_Expecter) CreateProject(ctx interface{}, project interface{}) *MockRepository_CreateProject_Call {
	return &MockRepository_CreateProject_Call{Call: _e.mock.On("CreateProject", ctx, project)}
}

func (_c *MockRepository_CreateProject_Call) Run(run func(ctx context.Context, project *models.Project)) *MockRepository_CreateProject_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*models.Project))
	})
	return _c
}

func (_c *MockRepository_CreateProject_Call) Return(_a0 error) *MockRepository_CreateProject_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockRepository_CreateProject_Call) RunAndReturn(run func(context.Context, *models.Project) error) *MockRepository_CreateProject_Call {
	_c.Call.Return(run)
	return _c
}

// CreateRule provides a mock function with given fields: ctx, rule
func (_m *MockRepository) CreateRule(ctx context.Context, rule *models.ForwardRule) error {
	ret := _m.Called(ctx, rule)

	if len(ret) == 0 {
		panic("no return value specified for CreateRule")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *models.ForwardRule) error); ok {
		r0 = rf(ctx, rule)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockRepository_CreateRule_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateRule'
type MockRepository_CreateRule_Call struct {
	*mock.Call
}

// CreateRule is a helper method to define mock.On call
//   - ctx context.Context
//   - rule *models.ForwardRule
func (_e *MockRepository_Expecter) CreateRule(ctx interface{}, rule interface{}) *MockRepository_CreateRule_Call {
	return &MockRepository_CreateRule_Call{Call: _e.mock.On("CreateRule", ctx, rule)}
}

func (_c *MockRepository_CreateRule_Call) Run(run func(ctx context.Context, rule *models.ForwardRule)) *MockRepository_CreateRule_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*models.ForwardRule))
	})
	return _c
}

func (_c *MockRepository_CreateRule_Call) Return(_a0 error) *MockRepository_CreateRule_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockRepository_CreateRule_Call) RunAndReturn(run func(context.Context, *models.ForwardRule) error) *MockRepository_CreateRule_Call {
	_c.Call.Return(run)
	return _c
}

// CreateToken provides a mock function with given fields: ctx, token
func (_m *MockRepository) CreateToken(ctx context.Context, token *models.Token) error {
	ret := _m.Called(ctx, token)

	if len(ret) == 0 {
		panic("no return value specified for CreateToken")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *models.Token) error); ok {
		r0 = rf(ctx, token)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockRepository_CreateToken_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateToken'
type MockRepository_CreateToken_Call struct {
	*mock.Call
}

// CreateToken is a helper method to define mock.On call
//   - ctx context.Context
//   - token *models.Token
func (_e *MockRepository_Expecter) CreateToken(ctx interface{}, token interface{}) *MockRepository_CreateToken_Call {
	return &MockRepository_CreateToken_Call{Call: _e.mock.On("CreateToken", ctx, token)}
}

func (_c *MockRepository_CreateToken_Call) Run(run func(ctx context.Context, token *models.Token)) *MockRepository_CreateToken_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*models.Token))
	})
	return _c
}

func (_c *MockRepository_CreateToken_Call) Return(_a0 error) *MockRepository_CreateToken_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockRepository_CreateToken_Call) RunAndReturn(run func(context.Context, *models.Token) error) *MockRepository_CreateToken_Call {
	_c.Call.Return(run)
	return _c
}

// CreateUser provides a mock function with given fields: ctx, user
func (_m *MockRepository) CreateUser(ctx context.Context, user *models.User) error {
	ret := _m.Called(ctx, user)

	if len(ret) == 0 {
		panic("no return value specified for CreateUser")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *models.User) error); ok {
		r0 = rf(ctx, user)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockRepository_CreateUser_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateUser'
type MockRepository_CreateUser_Call struct {
	*mock.Call
}

// CreateUser is a helper method to define mock.On call
//   - ctx context.Context
//   - user *models.User
func (_e *MockRepository_Expecter) CreateUser(ctx interface{}, user interface{}) *MockRepository_CreateUser_Call {
	return &MockRepository_CreateUser_Call{Call: _e.mock.On("CreateUser", ctx, user)}
}

func (_c *MockRepository_CreateUser_Call) Run(run func(ctx context.Context, user *models.User)) *MockRepository_CreateUser_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*models.User))
	})
	return _c
}

func (_c *MockRepository_CreateUser_Call) Return(_a0 error) *MockRepository_CreateUser_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockRepository_CreateUser_Call) RunAndReturn(run func(context.Context, *models.User) error) *MockRepository_CreateUser_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteInbox provides a mock function with given fields: ctx, id
func (_m *MockRepository) DeleteInbox(ctx context.Context, id int) error {
	ret := _m.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for DeleteInbox")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, int) error); ok {
		r0 = rf(ctx, id)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockRepository_DeleteInbox_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteInbox'
type MockRepository_DeleteInbox_Call struct {
	*mock.Call
}

// DeleteInbox is a helper method to define mock.On call
//   - ctx context.Context
//   - id int
func (_e *MockRepository_Expecter) DeleteInbox(ctx interface{}, id interface{}) *MockRepository_DeleteInbox_Call {
	return &MockRepository_DeleteInbox_Call{Call: _e.mock.On("DeleteInbox", ctx, id)}
}

func (_c *MockRepository_DeleteInbox_Call) Run(run func(ctx context.Context, id int)) *MockRepository_DeleteInbox_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int))
	})
	return _c
}

func (_c *MockRepository_DeleteInbox_Call) Return(_a0 error) *MockRepository_DeleteInbox_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockRepository_DeleteInbox_Call) RunAndReturn(run func(context.Context, int) error) *MockRepository_DeleteInbox_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteProject provides a mock function with given fields: ctx, id
func (_m *MockRepository) DeleteProject(ctx context.Context, id int) error {
	ret := _m.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for DeleteProject")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, int) error); ok {
		r0 = rf(ctx, id)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockRepository_DeleteProject_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteProject'
type MockRepository_DeleteProject_Call struct {
	*mock.Call
}

// DeleteProject is a helper method to define mock.On call
//   - ctx context.Context
//   - id int
func (_e *MockRepository_Expecter) DeleteProject(ctx interface{}, id interface{}) *MockRepository_DeleteProject_Call {
	return &MockRepository_DeleteProject_Call{Call: _e.mock.On("DeleteProject", ctx, id)}
}

func (_c *MockRepository_DeleteProject_Call) Run(run func(ctx context.Context, id int)) *MockRepository_DeleteProject_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int))
	})
	return _c
}

func (_c *MockRepository_DeleteProject_Call) Return(_a0 error) *MockRepository_DeleteProject_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockRepository_DeleteProject_Call) RunAndReturn(run func(context.Context, int) error) *MockRepository_DeleteProject_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteRule provides a mock function with given fields: ctx, id
func (_m *MockRepository) DeleteRule(ctx context.Context, id int) error {
	ret := _m.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for DeleteRule")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, int) error); ok {
		r0 = rf(ctx, id)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockRepository_DeleteRule_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteRule'
type MockRepository_DeleteRule_Call struct {
	*mock.Call
}

// DeleteRule is a helper method to define mock.On call
//   - ctx context.Context
//   - id int
func (_e *MockRepository_Expecter) DeleteRule(ctx interface{}, id interface{}) *MockRepository_DeleteRule_Call {
	return &MockRepository_DeleteRule_Call{Call: _e.mock.On("DeleteRule", ctx, id)}
}

func (_c *MockRepository_DeleteRule_Call) Run(run func(ctx context.Context, id int)) *MockRepository_DeleteRule_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int))
	})
	return _c
}

func (_c *MockRepository_DeleteRule_Call) Return(_a0 error) *MockRepository_DeleteRule_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockRepository_DeleteRule_Call) RunAndReturn(run func(context.Context, int) error) *MockRepository_DeleteRule_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteToken provides a mock function with given fields: ctx, tokenID
func (_m *MockRepository) DeleteToken(ctx context.Context, tokenID int) error {
	ret := _m.Called(ctx, tokenID)

	if len(ret) == 0 {
		panic("no return value specified for DeleteToken")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, int) error); ok {
		r0 = rf(ctx, tokenID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockRepository_DeleteToken_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteToken'
type MockRepository_DeleteToken_Call struct {
	*mock.Call
}

// DeleteToken is a helper method to define mock.On call
//   - ctx context.Context
//   - tokenID int
func (_e *MockRepository_Expecter) DeleteToken(ctx interface{}, tokenID interface{}) *MockRepository_DeleteToken_Call {
	return &MockRepository_DeleteToken_Call{Call: _e.mock.On("DeleteToken", ctx, tokenID)}
}

func (_c *MockRepository_DeleteToken_Call) Run(run func(ctx context.Context, tokenID int)) *MockRepository_DeleteToken_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int))
	})
	return _c
}

func (_c *MockRepository_DeleteToken_Call) Return(_a0 error) *MockRepository_DeleteToken_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockRepository_DeleteToken_Call) RunAndReturn(run func(context.Context, int) error) *MockRepository_DeleteToken_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteUser provides a mock function with given fields: ctx, userId
func (_m *MockRepository) DeleteUser(ctx context.Context, userId int) error {
	ret := _m.Called(ctx, userId)

	if len(ret) == 0 {
		panic("no return value specified for DeleteUser")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, int) error); ok {
		r0 = rf(ctx, userId)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockRepository_DeleteUser_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteUser'
type MockRepository_DeleteUser_Call struct {
	*mock.Call
}

// DeleteUser is a helper method to define mock.On call
//   - ctx context.Context
//   - userId int
func (_e *MockRepository_Expecter) DeleteUser(ctx interface{}, userId interface{}) *MockRepository_DeleteUser_Call {
	return &MockRepository_DeleteUser_Call{Call: _e.mock.On("DeleteUser", ctx, userId)}
}

func (_c *MockRepository_DeleteUser_Call) Run(run func(ctx context.Context, userId int)) *MockRepository_DeleteUser_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int))
	})
	return _c
}

func (_c *MockRepository_DeleteUser_Call) Return(_a0 error) *MockRepository_DeleteUser_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockRepository_DeleteUser_Call) RunAndReturn(run func(context.Context, int) error) *MockRepository_DeleteUser_Call {
	_c.Call.Return(run)
	return _c
}

// GetInbox provides a mock function with given fields: ctx, id
func (_m *MockRepository) GetInbox(ctx context.Context, id int) (*models.Inbox, error) {
	ret := _m.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for GetInbox")
	}

	var r0 *models.Inbox
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, int) (*models.Inbox, error)); ok {
		return rf(ctx, id)
	}
	if rf, ok := ret.Get(0).(func(context.Context, int) *models.Inbox); ok {
		r0 = rf(ctx, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*models.Inbox)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, int) error); ok {
		r1 = rf(ctx, id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockRepository_GetInbox_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetInbox'
type MockRepository_GetInbox_Call struct {
	*mock.Call
}

// GetInbox is a helper method to define mock.On call
//   - ctx context.Context
//   - id int
func (_e *MockRepository_Expecter) GetInbox(ctx interface{}, id interface{}) *MockRepository_GetInbox_Call {
	return &MockRepository_GetInbox_Call{Call: _e.mock.On("GetInbox", ctx, id)}
}

func (_c *MockRepository_GetInbox_Call) Run(run func(ctx context.Context, id int)) *MockRepository_GetInbox_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int))
	})
	return _c
}

func (_c *MockRepository_GetInbox_Call) Return(_a0 *models.Inbox, _a1 error) *MockRepository_GetInbox_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockRepository_GetInbox_Call) RunAndReturn(run func(context.Context, int) (*models.Inbox, error)) *MockRepository_GetInbox_Call {
	_c.Call.Return(run)
	return _c
}

// GetInboxByEmail provides a mock function with given fields: ctx, email
func (_m *MockRepository) GetInboxByEmail(ctx context.Context, email string) (*models.Inbox, error) {
	ret := _m.Called(ctx, email)

	if len(ret) == 0 {
		panic("no return value specified for GetInboxByEmail")
	}

	var r0 *models.Inbox
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (*models.Inbox, error)); ok {
		return rf(ctx, email)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) *models.Inbox); ok {
		r0 = rf(ctx, email)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*models.Inbox)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, email)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockRepository_GetInboxByEmail_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetInboxByEmail'
type MockRepository_GetInboxByEmail_Call struct {
	*mock.Call
}

// GetInboxByEmail is a helper method to define mock.On call
//   - ctx context.Context
//   - email string
func (_e *MockRepository_Expecter) GetInboxByEmail(ctx interface{}, email interface{}) *MockRepository_GetInboxByEmail_Call {
	return &MockRepository_GetInboxByEmail_Call{Call: _e.mock.On("GetInboxByEmail", ctx, email)}
}

func (_c *MockRepository_GetInboxByEmail_Call) Run(run func(ctx context.Context, email string)) *MockRepository_GetInboxByEmail_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockRepository_GetInboxByEmail_Call) Return(_a0 *models.Inbox, _a1 error) *MockRepository_GetInboxByEmail_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockRepository_GetInboxByEmail_Call) RunAndReturn(run func(context.Context, string) (*models.Inbox, error)) *MockRepository_GetInboxByEmail_Call {
	_c.Call.Return(run)
	return _c
}

// GetMessage provides a mock function with given fields: ctx, id
func (_m *MockRepository) GetMessage(ctx context.Context, id int) (*models.Message, error) {
	ret := _m.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for GetMessage")
	}

	var r0 *models.Message
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, int) (*models.Message, error)); ok {
		return rf(ctx, id)
	}
	if rf, ok := ret.Get(0).(func(context.Context, int) *models.Message); ok {
		r0 = rf(ctx, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*models.Message)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, int) error); ok {
		r1 = rf(ctx, id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockRepository_GetMessage_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetMessage'
type MockRepository_GetMessage_Call struct {
	*mock.Call
}

// GetMessage is a helper method to define mock.On call
//   - ctx context.Context
//   - id int
func (_e *MockRepository_Expecter) GetMessage(ctx interface{}, id interface{}) *MockRepository_GetMessage_Call {
	return &MockRepository_GetMessage_Call{Call: _e.mock.On("GetMessage", ctx, id)}
}

func (_c *MockRepository_GetMessage_Call) Run(run func(ctx context.Context, id int)) *MockRepository_GetMessage_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int))
	})
	return _c
}

func (_c *MockRepository_GetMessage_Call) Return(_a0 *models.Message, _a1 error) *MockRepository_GetMessage_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockRepository_GetMessage_Call) RunAndReturn(run func(context.Context, int) (*models.Message, error)) *MockRepository_GetMessage_Call {
	_c.Call.Return(run)
	return _c
}

// GetProject provides a mock function with given fields: ctx, id
func (_m *MockRepository) GetProject(ctx context.Context, id int) (*models.Project, error) {
	ret := _m.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for GetProject")
	}

	var r0 *models.Project
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, int) (*models.Project, error)); ok {
		return rf(ctx, id)
	}
	if rf, ok := ret.Get(0).(func(context.Context, int) *models.Project); ok {
		r0 = rf(ctx, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*models.Project)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, int) error); ok {
		r1 = rf(ctx, id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockRepository_GetProject_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetProject'
type MockRepository_GetProject_Call struct {
	*mock.Call
}

// GetProject is a helper method to define mock.On call
//   - ctx context.Context
//   - id int
func (_e *MockRepository_Expecter) GetProject(ctx interface{}, id interface{}) *MockRepository_GetProject_Call {
	return &MockRepository_GetProject_Call{Call: _e.mock.On("GetProject", ctx, id)}
}

func (_c *MockRepository_GetProject_Call) Run(run func(ctx context.Context, id int)) *MockRepository_GetProject_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int))
	})
	return _c
}

func (_c *MockRepository_GetProject_Call) Return(_a0 *models.Project, _a1 error) *MockRepository_GetProject_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockRepository_GetProject_Call) RunAndReturn(run func(context.Context, int) (*models.Project, error)) *MockRepository_GetProject_Call {
	_c.Call.Return(run)
	return _c
}

// GetRule provides a mock function with given fields: ctx, id
func (_m *MockRepository) GetRule(ctx context.Context, id int) (*models.ForwardRule, error) {
	ret := _m.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for GetRule")
	}

	var r0 *models.ForwardRule
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, int) (*models.ForwardRule, error)); ok {
		return rf(ctx, id)
	}
	if rf, ok := ret.Get(0).(func(context.Context, int) *models.ForwardRule); ok {
		r0 = rf(ctx, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*models.ForwardRule)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, int) error); ok {
		r1 = rf(ctx, id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockRepository_GetRule_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetRule'
type MockRepository_GetRule_Call struct {
	*mock.Call
}

// GetRule is a helper method to define mock.On call
//   - ctx context.Context
//   - id int
func (_e *MockRepository_Expecter) GetRule(ctx interface{}, id interface{}) *MockRepository_GetRule_Call {
	return &MockRepository_GetRule_Call{Call: _e.mock.On("GetRule", ctx, id)}
}

func (_c *MockRepository_GetRule_Call) Run(run func(ctx context.Context, id int)) *MockRepository_GetRule_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int))
	})
	return _c
}

func (_c *MockRepository_GetRule_Call) Return(_a0 *models.ForwardRule, _a1 error) *MockRepository_GetRule_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockRepository_GetRule_Call) RunAndReturn(run func(context.Context, int) (*models.ForwardRule, error)) *MockRepository_GetRule_Call {
	_c.Call.Return(run)
	return _c
}

// GetTokenByUser provides a mock function with given fields: ctx, userID, tokenID
func (_m *MockRepository) GetTokenByUser(ctx context.Context, userID int, tokenID int) (*models.Token, error) {
	ret := _m.Called(ctx, userID, tokenID)

	if len(ret) == 0 {
		panic("no return value specified for GetTokenByUser")
	}

	var r0 *models.Token
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, int, int) (*models.Token, error)); ok {
		return rf(ctx, userID, tokenID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, int, int) *models.Token); ok {
		r0 = rf(ctx, userID, tokenID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*models.Token)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, int, int) error); ok {
		r1 = rf(ctx, userID, tokenID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockRepository_GetTokenByUser_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetTokenByUser'
type MockRepository_GetTokenByUser_Call struct {
	*mock.Call
}

// GetTokenByUser is a helper method to define mock.On call
//   - ctx context.Context
//   - userID int
//   - tokenID int
func (_e *MockRepository_Expecter) GetTokenByUser(ctx interface{}, userID interface{}, tokenID interface{}) *MockRepository_GetTokenByUser_Call {
	return &MockRepository_GetTokenByUser_Call{Call: _e.mock.On("GetTokenByUser", ctx, userID, tokenID)}
}

func (_c *MockRepository_GetTokenByUser_Call) Run(run func(ctx context.Context, userID int, tokenID int)) *MockRepository_GetTokenByUser_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int), args[2].(int))
	})
	return _c
}

func (_c *MockRepository_GetTokenByUser_Call) Return(_a0 *models.Token, _a1 error) *MockRepository_GetTokenByUser_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockRepository_GetTokenByUser_Call) RunAndReturn(run func(context.Context, int, int) (*models.Token, error)) *MockRepository_GetTokenByUser_Call {
	_c.Call.Return(run)
	return _c
}

// GetUser provides a mock function with given fields: ctx, id
func (_m *MockRepository) GetUser(ctx context.Context, id int) (*models.User, error) {
	ret := _m.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for GetUser")
	}

	var r0 *models.User
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, int) (*models.User, error)); ok {
		return rf(ctx, id)
	}
	if rf, ok := ret.Get(0).(func(context.Context, int) *models.User); ok {
		r0 = rf(ctx, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*models.User)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, int) error); ok {
		r1 = rf(ctx, id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockRepository_GetUser_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetUser'
type MockRepository_GetUser_Call struct {
	*mock.Call
}

// GetUser is a helper method to define mock.On call
//   - ctx context.Context
//   - id int
func (_e *MockRepository_Expecter) GetUser(ctx interface{}, id interface{}) *MockRepository_GetUser_Call {
	return &MockRepository_GetUser_Call{Call: _e.mock.On("GetUser", ctx, id)}
}

func (_c *MockRepository_GetUser_Call) Run(run func(ctx context.Context, id int)) *MockRepository_GetUser_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int))
	})
	return _c
}

func (_c *MockRepository_GetUser_Call) Return(_a0 *models.User, _a1 error) *MockRepository_GetUser_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockRepository_GetUser_Call) RunAndReturn(run func(context.Context, int) (*models.User, error)) *MockRepository_GetUser_Call {
	_c.Call.Return(run)
	return _c
}

// GetUserByUsername provides a mock function with given fields: ctx, username
func (_m *MockRepository) GetUserByUsername(ctx context.Context, username string) (*models.User, error) {
	ret := _m.Called(ctx, username)

	if len(ret) == 0 {
		panic("no return value specified for GetUserByUsername")
	}

	var r0 *models.User
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (*models.User, error)); ok {
		return rf(ctx, username)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) *models.User); ok {
		r0 = rf(ctx, username)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*models.User)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, username)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockRepository_GetUserByUsername_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetUserByUsername'
type MockRepository_GetUserByUsername_Call struct {
	*mock.Call
}

// GetUserByUsername is a helper method to define mock.On call
//   - ctx context.Context
//   - username string
func (_e *MockRepository_Expecter) GetUserByUsername(ctx interface{}, username interface{}) *MockRepository_GetUserByUsername_Call {
	return &MockRepository_GetUserByUsername_Call{Call: _e.mock.On("GetUserByUsername", ctx, username)}
}

func (_c *MockRepository_GetUserByUsername_Call) Run(run func(ctx context.Context, username string)) *MockRepository_GetUserByUsername_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockRepository_GetUserByUsername_Call) Return(_a0 *models.User, _a1 error) *MockRepository_GetUserByUsername_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockRepository_GetUserByUsername_Call) RunAndReturn(run func(context.Context, string) (*models.User, error)) *MockRepository_GetUserByUsername_Call {
	_c.Call.Return(run)
	return _c
}

// ListInboxesByProject provides a mock function with given fields: ctx, projectID, limit, offset
func (_m *MockRepository) ListInboxesByProject(ctx context.Context, projectID int, limit int, offset int) ([]*models.Inbox, int, error) {
	ret := _m.Called(ctx, projectID, limit, offset)

	if len(ret) == 0 {
		panic("no return value specified for ListInboxesByProject")
	}

	var r0 []*models.Inbox
	var r1 int
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, int, int, int) ([]*models.Inbox, int, error)); ok {
		return rf(ctx, projectID, limit, offset)
	}
	if rf, ok := ret.Get(0).(func(context.Context, int, int, int) []*models.Inbox); ok {
		r0 = rf(ctx, projectID, limit, offset)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*models.Inbox)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, int, int, int) int); ok {
		r1 = rf(ctx, projectID, limit, offset)
	} else {
		r1 = ret.Get(1).(int)
	}

	if rf, ok := ret.Get(2).(func(context.Context, int, int, int) error); ok {
		r2 = rf(ctx, projectID, limit, offset)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// MockRepository_ListInboxesByProject_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListInboxesByProject'
type MockRepository_ListInboxesByProject_Call struct {
	*mock.Call
}

// ListInboxesByProject is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID int
//   - limit int
//   - offset int
func (_e *MockRepository_Expecter) ListInboxesByProject(ctx interface{}, projectID interface{}, limit interface{}, offset interface{}) *MockRepository_ListInboxesByProject_Call {
	return &MockRepository_ListInboxesByProject_Call{Call: _e.mock.On("ListInboxesByProject", ctx, projectID, limit, offset)}
}

func (_c *MockRepository_ListInboxesByProject_Call) Run(run func(ctx context.Context, projectID int, limit int, offset int)) *MockRepository_ListInboxesByProject_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int), args[2].(int), args[3].(int))
	})
	return _c
}

func (_c *MockRepository_ListInboxesByProject_Call) Return(_a0 []*models.Inbox, _a1 int, _a2 error) *MockRepository_ListInboxesByProject_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *MockRepository_ListInboxesByProject_Call) RunAndReturn(run func(context.Context, int, int, int) ([]*models.Inbox, int, error)) *MockRepository_ListInboxesByProject_Call {
	_c.Call.Return(run)
	return _c
}

// ListMessagesByInbox provides a mock function with given fields: ctx, inboxID, limit, offset
func (_m *MockRepository) ListMessagesByInbox(ctx context.Context, inboxID int, limit int, offset int) ([]*models.Message, int, error) {
	ret := _m.Called(ctx, inboxID, limit, offset)

	if len(ret) == 0 {
		panic("no return value specified for ListMessagesByInbox")
	}

	var r0 []*models.Message
	var r1 int
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, int, int, int) ([]*models.Message, int, error)); ok {
		return rf(ctx, inboxID, limit, offset)
	}
	if rf, ok := ret.Get(0).(func(context.Context, int, int, int) []*models.Message); ok {
		r0 = rf(ctx, inboxID, limit, offset)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*models.Message)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, int, int, int) int); ok {
		r1 = rf(ctx, inboxID, limit, offset)
	} else {
		r1 = ret.Get(1).(int)
	}

	if rf, ok := ret.Get(2).(func(context.Context, int, int, int) error); ok {
		r2 = rf(ctx, inboxID, limit, offset)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// MockRepository_ListMessagesByInbox_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListMessagesByInbox'
type MockRepository_ListMessagesByInbox_Call struct {
	*mock.Call
}

// ListMessagesByInbox is a helper method to define mock.On call
//   - ctx context.Context
//   - inboxID int
//   - limit int
//   - offset int
func (_e *MockRepository_Expecter) ListMessagesByInbox(ctx interface{}, inboxID interface{}, limit interface{}, offset interface{}) *MockRepository_ListMessagesByInbox_Call {
	return &MockRepository_ListMessagesByInbox_Call{Call: _e.mock.On("ListMessagesByInbox", ctx, inboxID, limit, offset)}
}

func (_c *MockRepository_ListMessagesByInbox_Call) Run(run func(ctx context.Context, inboxID int, limit int, offset int)) *MockRepository_ListMessagesByInbox_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int), args[2].(int), args[3].(int))
	})
	return _c
}

func (_c *MockRepository_ListMessagesByInbox_Call) Return(_a0 []*models.Message, _a1 int, _a2 error) *MockRepository_ListMessagesByInbox_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *MockRepository_ListMessagesByInbox_Call) RunAndReturn(run func(context.Context, int, int, int) ([]*models.Message, int, error)) *MockRepository_ListMessagesByInbox_Call {
	_c.Call.Return(run)
	return _c
}

// ListProjects provides a mock function with given fields: ctx, limit, offset
func (_m *MockRepository) ListProjects(ctx context.Context, limit int, offset int) ([]*models.Project, int, error) {
	ret := _m.Called(ctx, limit, offset)

	if len(ret) == 0 {
		panic("no return value specified for ListProjects")
	}

	var r0 []*models.Project
	var r1 int
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, int, int) ([]*models.Project, int, error)); ok {
		return rf(ctx, limit, offset)
	}
	if rf, ok := ret.Get(0).(func(context.Context, int, int) []*models.Project); ok {
		r0 = rf(ctx, limit, offset)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*models.Project)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, int, int) int); ok {
		r1 = rf(ctx, limit, offset)
	} else {
		r1 = ret.Get(1).(int)
	}

	if rf, ok := ret.Get(2).(func(context.Context, int, int) error); ok {
		r2 = rf(ctx, limit, offset)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// MockRepository_ListProjects_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListProjects'
type MockRepository_ListProjects_Call struct {
	*mock.Call
}

// ListProjects is a helper method to define mock.On call
//   - ctx context.Context
//   - limit int
//   - offset int
func (_e *MockRepository_Expecter) ListProjects(ctx interface{}, limit interface{}, offset interface{}) *MockRepository_ListProjects_Call {
	return &MockRepository_ListProjects_Call{Call: _e.mock.On("ListProjects", ctx, limit, offset)}
}

func (_c *MockRepository_ListProjects_Call) Run(run func(ctx context.Context, limit int, offset int)) *MockRepository_ListProjects_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int), args[2].(int))
	})
	return _c
}

func (_c *MockRepository_ListProjects_Call) Return(_a0 []*models.Project, _a1 int, _a2 error) *MockRepository_ListProjects_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *MockRepository_ListProjects_Call) RunAndReturn(run func(context.Context, int, int) ([]*models.Project, int, error)) *MockRepository_ListProjects_Call {
	_c.Call.Return(run)
	return _c
}

// ListProjectsByUser provides a mock function with given fields: ctx, userID, limit, offset
func (_m *MockRepository) ListProjectsByUser(ctx context.Context, userID int, limit int, offset int) ([]*models.Project, int, error) {
	ret := _m.Called(ctx, userID, limit, offset)

	if len(ret) == 0 {
		panic("no return value specified for ListProjectsByUser")
	}

	var r0 []*models.Project
	var r1 int
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, int, int, int) ([]*models.Project, int, error)); ok {
		return rf(ctx, userID, limit, offset)
	}
	if rf, ok := ret.Get(0).(func(context.Context, int, int, int) []*models.Project); ok {
		r0 = rf(ctx, userID, limit, offset)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*models.Project)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, int, int, int) int); ok {
		r1 = rf(ctx, userID, limit, offset)
	} else {
		r1 = ret.Get(1).(int)
	}

	if rf, ok := ret.Get(2).(func(context.Context, int, int, int) error); ok {
		r2 = rf(ctx, userID, limit, offset)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// MockRepository_ListProjectsByUser_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListProjectsByUser'
type MockRepository_ListProjectsByUser_Call struct {
	*mock.Call
}

// ListProjectsByUser is a helper method to define mock.On call
//   - ctx context.Context
//   - userID int
//   - limit int
//   - offset int
func (_e *MockRepository_Expecter) ListProjectsByUser(ctx interface{}, userID interface{}, limit interface{}, offset interface{}) *MockRepository_ListProjectsByUser_Call {
	return &MockRepository_ListProjectsByUser_Call{Call: _e.mock.On("ListProjectsByUser", ctx, userID, limit, offset)}
}

func (_c *MockRepository_ListProjectsByUser_Call) Run(run func(ctx context.Context, userID int, limit int, offset int)) *MockRepository_ListProjectsByUser_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int), args[2].(int), args[3].(int))
	})
	return _c
}

func (_c *MockRepository_ListProjectsByUser_Call) Return(_a0 []*models.Project, _a1 int, _a2 error) *MockRepository_ListProjectsByUser_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *MockRepository_ListProjectsByUser_Call) RunAndReturn(run func(context.Context, int, int, int) ([]*models.Project, int, error)) *MockRepository_ListProjectsByUser_Call {
	_c.Call.Return(run)
	return _c
}

// ListRules provides a mock function with given fields: ctx, limit, offset
func (_m *MockRepository) ListRules(ctx context.Context, limit int, offset int) ([]*models.ForwardRule, int, error) {
	ret := _m.Called(ctx, limit, offset)

	if len(ret) == 0 {
		panic("no return value specified for ListRules")
	}

	var r0 []*models.ForwardRule
	var r1 int
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, int, int) ([]*models.ForwardRule, int, error)); ok {
		return rf(ctx, limit, offset)
	}
	if rf, ok := ret.Get(0).(func(context.Context, int, int) []*models.ForwardRule); ok {
		r0 = rf(ctx, limit, offset)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*models.ForwardRule)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, int, int) int); ok {
		r1 = rf(ctx, limit, offset)
	} else {
		r1 = ret.Get(1).(int)
	}

	if rf, ok := ret.Get(2).(func(context.Context, int, int) error); ok {
		r2 = rf(ctx, limit, offset)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// MockRepository_ListRules_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListRules'
type MockRepository_ListRules_Call struct {
	*mock.Call
}

// ListRules is a helper method to define mock.On call
//   - ctx context.Context
//   - limit int
//   - offset int
func (_e *MockRepository_Expecter) ListRules(ctx interface{}, limit interface{}, offset interface{}) *MockRepository_ListRules_Call {
	return &MockRepository_ListRules_Call{Call: _e.mock.On("ListRules", ctx, limit, offset)}
}

func (_c *MockRepository_ListRules_Call) Run(run func(ctx context.Context, limit int, offset int)) *MockRepository_ListRules_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int), args[2].(int))
	})
	return _c
}

func (_c *MockRepository_ListRules_Call) Return(_a0 []*models.ForwardRule, _a1 int, _a2 error) *MockRepository_ListRules_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *MockRepository_ListRules_Call) RunAndReturn(run func(context.Context, int, int) ([]*models.ForwardRule, int, error)) *MockRepository_ListRules_Call {
	_c.Call.Return(run)
	return _c
}

// ListRulesByInbox provides a mock function with given fields: ctx, inboxID, limit, offset
func (_m *MockRepository) ListRulesByInbox(ctx context.Context, inboxID int, limit int, offset int) ([]*models.ForwardRule, int, error) {
	ret := _m.Called(ctx, inboxID, limit, offset)

	if len(ret) == 0 {
		panic("no return value specified for ListRulesByInbox")
	}

	var r0 []*models.ForwardRule
	var r1 int
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, int, int, int) ([]*models.ForwardRule, int, error)); ok {
		return rf(ctx, inboxID, limit, offset)
	}
	if rf, ok := ret.Get(0).(func(context.Context, int, int, int) []*models.ForwardRule); ok {
		r0 = rf(ctx, inboxID, limit, offset)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*models.ForwardRule)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, int, int, int) int); ok {
		r1 = rf(ctx, inboxID, limit, offset)
	} else {
		r1 = ret.Get(1).(int)
	}

	if rf, ok := ret.Get(2).(func(context.Context, int, int, int) error); ok {
		r2 = rf(ctx, inboxID, limit, offset)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// MockRepository_ListRulesByInbox_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListRulesByInbox'
type MockRepository_ListRulesByInbox_Call struct {
	*mock.Call
}

// ListRulesByInbox is a helper method to define mock.On call
//   - ctx context.Context
//   - inboxID int
//   - limit int
//   - offset int
func (_e *MockRepository_Expecter) ListRulesByInbox(ctx interface{}, inboxID interface{}, limit interface{}, offset interface{}) *MockRepository_ListRulesByInbox_Call {
	return &MockRepository_ListRulesByInbox_Call{Call: _e.mock.On("ListRulesByInbox", ctx, inboxID, limit, offset)}
}

func (_c *MockRepository_ListRulesByInbox_Call) Run(run func(ctx context.Context, inboxID int, limit int, offset int)) *MockRepository_ListRulesByInbox_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int), args[2].(int), args[3].(int))
	})
	return _c
}

func (_c *MockRepository_ListRulesByInbox_Call) Return(_a0 []*models.ForwardRule, _a1 int, _a2 error) *MockRepository_ListRulesByInbox_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *MockRepository_ListRulesByInbox_Call) RunAndReturn(run func(context.Context, int, int, int) ([]*models.ForwardRule, int, error)) *MockRepository_ListRulesByInbox_Call {
	_c.Call.Return(run)
	return _c
}

// ListTokensByUser provides a mock function with given fields: ctx, userID, limit, offset
func (_m *MockRepository) ListTokensByUser(ctx context.Context, userID int, limit int, offset int) ([]*models.Token, int, error) {
	ret := _m.Called(ctx, userID, limit, offset)

	if len(ret) == 0 {
		panic("no return value specified for ListTokensByUser")
	}

	var r0 []*models.Token
	var r1 int
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, int, int, int) ([]*models.Token, int, error)); ok {
		return rf(ctx, userID, limit, offset)
	}
	if rf, ok := ret.Get(0).(func(context.Context, int, int, int) []*models.Token); ok {
		r0 = rf(ctx, userID, limit, offset)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*models.Token)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, int, int, int) int); ok {
		r1 = rf(ctx, userID, limit, offset)
	} else {
		r1 = ret.Get(1).(int)
	}

	if rf, ok := ret.Get(2).(func(context.Context, int, int, int) error); ok {
		r2 = rf(ctx, userID, limit, offset)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// MockRepository_ListTokensByUser_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListTokensByUser'
type MockRepository_ListTokensByUser_Call struct {
	*mock.Call
}

// ListTokensByUser is a helper method to define mock.On call
//   - ctx context.Context
//   - userID int
//   - limit int
//   - offset int
func (_e *MockRepository_Expecter) ListTokensByUser(ctx interface{}, userID interface{}, limit interface{}, offset interface{}) *MockRepository_ListTokensByUser_Call {
	return &MockRepository_ListTokensByUser_Call{Call: _e.mock.On("ListTokensByUser", ctx, userID, limit, offset)}
}

func (_c *MockRepository_ListTokensByUser_Call) Run(run func(ctx context.Context, userID int, limit int, offset int)) *MockRepository_ListTokensByUser_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int), args[2].(int), args[3].(int))
	})
	return _c
}

func (_c *MockRepository_ListTokensByUser_Call) Return(_a0 []*models.Token, _a1 int, _a2 error) *MockRepository_ListTokensByUser_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *MockRepository_ListTokensByUser_Call) RunAndReturn(run func(context.Context, int, int, int) ([]*models.Token, int, error)) *MockRepository_ListTokensByUser_Call {
	_c.Call.Return(run)
	return _c
}

// ListUsers provides a mock function with given fields: ctx, limit, offset
func (_m *MockRepository) ListUsers(ctx context.Context, limit int, offset int) ([]*models.User, int, error) {
	ret := _m.Called(ctx, limit, offset)

	if len(ret) == 0 {
		panic("no return value specified for ListUsers")
	}

	var r0 []*models.User
	var r1 int
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, int, int) ([]*models.User, int, error)); ok {
		return rf(ctx, limit, offset)
	}
	if rf, ok := ret.Get(0).(func(context.Context, int, int) []*models.User); ok {
		r0 = rf(ctx, limit, offset)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*models.User)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, int, int) int); ok {
		r1 = rf(ctx, limit, offset)
	} else {
		r1 = ret.Get(1).(int)
	}

	if rf, ok := ret.Get(2).(func(context.Context, int, int) error); ok {
		r2 = rf(ctx, limit, offset)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// MockRepository_ListUsers_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListUsers'
type MockRepository_ListUsers_Call struct {
	*mock.Call
}

// ListUsers is a helper method to define mock.On call
//   - ctx context.Context
//   - limit int
//   - offset int
func (_e *MockRepository_Expecter) ListUsers(ctx interface{}, limit interface{}, offset interface{}) *MockRepository_ListUsers_Call {
	return &MockRepository_ListUsers_Call{Call: _e.mock.On("ListUsers", ctx, limit, offset)}
}

func (_c *MockRepository_ListUsers_Call) Run(run func(ctx context.Context, limit int, offset int)) *MockRepository_ListUsers_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int), args[2].(int))
	})
	return _c
}

func (_c *MockRepository_ListUsers_Call) Return(_a0 []*models.User, _a1 int, _a2 error) *MockRepository_ListUsers_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *MockRepository_ListUsers_Call) RunAndReturn(run func(context.Context, int, int) ([]*models.User, int, error)) *MockRepository_ListUsers_Call {
	_c.Call.Return(run)
	return _c
}

// ProjectAddUser provides a mock function with given fields: ctx, projectUser
func (_m *MockRepository) ProjectAddUser(ctx context.Context, projectUser *models.ProjectUser) error {
	ret := _m.Called(ctx, projectUser)

	if len(ret) == 0 {
		panic("no return value specified for ProjectAddUser")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *models.ProjectUser) error); ok {
		r0 = rf(ctx, projectUser)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockRepository_ProjectAddUser_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ProjectAddUser'
type MockRepository_ProjectAddUser_Call struct {
	*mock.Call
}

// ProjectAddUser is a helper method to define mock.On call
//   - ctx context.Context
//   - projectUser *models.ProjectUser
func (_e *MockRepository_Expecter) ProjectAddUser(ctx interface{}, projectUser interface{}) *MockRepository_ProjectAddUser_Call {
	return &MockRepository_ProjectAddUser_Call{Call: _e.mock.On("ProjectAddUser", ctx, projectUser)}
}

func (_c *MockRepository_ProjectAddUser_Call) Run(run func(ctx context.Context, projectUser *models.ProjectUser)) *MockRepository_ProjectAddUser_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*models.ProjectUser))
	})
	return _c
}

func (_c *MockRepository_ProjectAddUser_Call) Return(_a0 error) *MockRepository_ProjectAddUser_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockRepository_ProjectAddUser_Call) RunAndReturn(run func(context.Context, *models.ProjectUser) error) *MockRepository_ProjectAddUser_Call {
	_c.Call.Return(run)
	return _c
}

// ProjectRemoveUser provides a mock function with given fields: ctx, projectID, userID
func (_m *MockRepository) ProjectRemoveUser(ctx context.Context, projectID int, userID int) error {
	ret := _m.Called(ctx, projectID, userID)

	if len(ret) == 0 {
		panic("no return value specified for ProjectRemoveUser")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, int, int) error); ok {
		r0 = rf(ctx, projectID, userID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockRepository_ProjectRemoveUser_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ProjectRemoveUser'
type MockRepository_ProjectRemoveUser_Call struct {
	*mock.Call
}

// ProjectRemoveUser is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID int
//   - userID int
func (_e *MockRepository_Expecter) ProjectRemoveUser(ctx interface{}, projectID interface{}, userID interface{}) *MockRepository_ProjectRemoveUser_Call {
	return &MockRepository_ProjectRemoveUser_Call{Call: _e.mock.On("ProjectRemoveUser", ctx, projectID, userID)}
}

func (_c *MockRepository_ProjectRemoveUser_Call) Run(run func(ctx context.Context, projectID int, userID int)) *MockRepository_ProjectRemoveUser_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int), args[2].(int))
	})
	return _c
}

func (_c *MockRepository_ProjectRemoveUser_Call) Return(_a0 error) *MockRepository_ProjectRemoveUser_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockRepository_ProjectRemoveUser_Call) RunAndReturn(run func(context.Context, int, int) error) *MockRepository_ProjectRemoveUser_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateInbox provides a mock function with given fields: ctx, inbox
func (_m *MockRepository) UpdateInbox(ctx context.Context, inbox *models.Inbox) error {
	ret := _m.Called(ctx, inbox)

	if len(ret) == 0 {
		panic("no return value specified for UpdateInbox")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *models.Inbox) error); ok {
		r0 = rf(ctx, inbox)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockRepository_UpdateInbox_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateInbox'
type MockRepository_UpdateInbox_Call struct {
	*mock.Call
}

// UpdateInbox is a helper method to define mock.On call
//   - ctx context.Context
//   - inbox *models.Inbox
func (_e *MockRepository_Expecter) UpdateInbox(ctx interface{}, inbox interface{}) *MockRepository_UpdateInbox_Call {
	return &MockRepository_UpdateInbox_Call{Call: _e.mock.On("UpdateInbox", ctx, inbox)}
}

func (_c *MockRepository_UpdateInbox_Call) Run(run func(ctx context.Context, inbox *models.Inbox)) *MockRepository_UpdateInbox_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*models.Inbox))
	})
	return _c
}

func (_c *MockRepository_UpdateInbox_Call) Return(_a0 error) *MockRepository_UpdateInbox_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockRepository_UpdateInbox_Call) RunAndReturn(run func(context.Context, *models.Inbox) error) *MockRepository_UpdateInbox_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateProject provides a mock function with given fields: ctx, project
func (_m *MockRepository) UpdateProject(ctx context.Context, project *models.Project) error {
	ret := _m.Called(ctx, project)

	if len(ret) == 0 {
		panic("no return value specified for UpdateProject")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *models.Project) error); ok {
		r0 = rf(ctx, project)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockRepository_UpdateProject_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateProject'
type MockRepository_UpdateProject_Call struct {
	*mock.Call
}

// UpdateProject is a helper method to define mock.On call
//   - ctx context.Context
//   - project *models.Project
func (_e *MockRepository_Expecter) UpdateProject(ctx interface{}, project interface{}) *MockRepository_UpdateProject_Call {
	return &MockRepository_UpdateProject_Call{Call: _e.mock.On("UpdateProject", ctx, project)}
}

func (_c *MockRepository_UpdateProject_Call) Run(run func(ctx context.Context, project *models.Project)) *MockRepository_UpdateProject_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*models.Project))
	})
	return _c
}

func (_c *MockRepository_UpdateProject_Call) Return(_a0 error) *MockRepository_UpdateProject_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockRepository_UpdateProject_Call) RunAndReturn(run func(context.Context, *models.Project) error) *MockRepository_UpdateProject_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateRule provides a mock function with given fields: ctx, rule
func (_m *MockRepository) UpdateRule(ctx context.Context, rule *models.ForwardRule) error {
	ret := _m.Called(ctx, rule)

	if len(ret) == 0 {
		panic("no return value specified for UpdateRule")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *models.ForwardRule) error); ok {
		r0 = rf(ctx, rule)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockRepository_UpdateRule_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateRule'
type MockRepository_UpdateRule_Call struct {
	*mock.Call
}

// UpdateRule is a helper method to define mock.On call
//   - ctx context.Context
//   - rule *models.ForwardRule
func (_e *MockRepository_Expecter) UpdateRule(ctx interface{}, rule interface{}) *MockRepository_UpdateRule_Call {
	return &MockRepository_UpdateRule_Call{Call: _e.mock.On("UpdateRule", ctx, rule)}
}

func (_c *MockRepository_UpdateRule_Call) Run(run func(ctx context.Context, rule *models.ForwardRule)) *MockRepository_UpdateRule_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*models.ForwardRule))
	})
	return _c
}

func (_c *MockRepository_UpdateRule_Call) Return(_a0 error) *MockRepository_UpdateRule_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockRepository_UpdateRule_Call) RunAndReturn(run func(context.Context, *models.ForwardRule) error) *MockRepository_UpdateRule_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateUser provides a mock function with given fields: ctx, user
func (_m *MockRepository) UpdateUser(ctx context.Context, user *models.User) error {
	ret := _m.Called(ctx, user)

	if len(ret) == 0 {
		panic("no return value specified for UpdateUser")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *models.User) error); ok {
		r0 = rf(ctx, user)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockRepository_UpdateUser_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateUser'
type MockRepository_UpdateUser_Call struct {
	*mock.Call
}

// UpdateUser is a helper method to define mock.On call
//   - ctx context.Context
//   - user *models.User
func (_e *MockRepository_Expecter) UpdateUser(ctx interface{}, user interface{}) *MockRepository_UpdateUser_Call {
	return &MockRepository_UpdateUser_Call{Call: _e.mock.On("UpdateUser", ctx, user)}
}

func (_c *MockRepository_UpdateUser_Call) Run(run func(ctx context.Context, user *models.User)) *MockRepository_UpdateUser_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*models.User))
	})
	return _c
}

func (_c *MockRepository_UpdateUser_Call) Return(_a0 error) *MockRepository_UpdateUser_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockRepository_UpdateUser_Call) RunAndReturn(run func(context.Context, *models.User) error) *MockRepository_UpdateUser_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockRepository creates a new instance of MockRepository. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockRepository(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockRepository {
	mock := &MockRepository{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
