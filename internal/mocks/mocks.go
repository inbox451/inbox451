// Code generated by mockery; DO NOT EDIT.
// github.com/vektra/mockery
// template: testify

package mocks

import (
	"context"
	"inbox451/internal/models"

	mock "github.com/stretchr/testify/mock"
)

// NewRepository creates a new instance of Repository. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewRepository(t interface {
	mock.TestingT
	Cleanup(func())
}) *Repository {
	mock := &Repository{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// Repository is an autogenerated mock type for the Repository type
type Repository struct {
	mock.Mock
}

type Repository_Expecter struct {
	mock *mock.Mock
}

func (_m *Repository) EXPECT() *Repository_Expecter {
	return &Repository_Expecter{mock: &_m.Mock}
}

// CreateInbox provides a mock function for the type Repository
func (_mock *Repository) CreateInbox(ctx context.Context, inbox *models.Inbox) error {
	ret := _mock.Called(ctx, inbox)

	if len(ret) == 0 {
		panic("no return value specified for CreateInbox")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *models.Inbox) error); ok {
		r0 = returnFunc(ctx, inbox)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// Repository_CreateInbox_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateInbox'
type Repository_CreateInbox_Call struct {
	*mock.Call
}

// CreateInbox is a helper method to define mock.On call
//   - ctx context.Context
//   - inbox *models.Inbox
func (_e *Repository_Expecter) CreateInbox(ctx interface{}, inbox interface{}) *Repository_CreateInbox_Call {
	return &Repository_CreateInbox_Call{Call: _e.mock.On("CreateInbox", ctx, inbox)}
}

func (_c *Repository_CreateInbox_Call) Run(run func(ctx context.Context, inbox *models.Inbox)) *Repository_CreateInbox_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *models.Inbox
		if args[1] != nil {
			arg1 = args[1].(*models.Inbox)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *Repository_CreateInbox_Call) Return(err error) *Repository_CreateInbox_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *Repository_CreateInbox_Call) RunAndReturn(run func(ctx context.Context, inbox *models.Inbox) error) *Repository_CreateInbox_Call {
	_c.Call.Return(run)
	return _c
}

// CreateMessage provides a mock function for the type Repository
func (_mock *Repository) CreateMessage(ctx context.Context, message *models.Message) error {
	ret := _mock.Called(ctx, message)

	if len(ret) == 0 {
		panic("no return value specified for CreateMessage")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *models.Message) error); ok {
		r0 = returnFunc(ctx, message)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// Repository_CreateMessage_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateMessage'
type Repository_CreateMessage_Call struct {
	*mock.Call
}

// CreateMessage is a helper method to define mock.On call
//   - ctx context.Context
//   - message *models.Message
func (_e *Repository_Expecter) CreateMessage(ctx interface{}, message interface{}) *Repository_CreateMessage_Call {
	return &Repository_CreateMessage_Call{Call: _e.mock.On("CreateMessage", ctx, message)}
}

func (_c *Repository_CreateMessage_Call) Run(run func(ctx context.Context, message *models.Message)) *Repository_CreateMessage_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *models.Message
		if args[1] != nil {
			arg1 = args[1].(*models.Message)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *Repository_CreateMessage_Call) Return(err error) *Repository_CreateMessage_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *Repository_CreateMessage_Call) RunAndReturn(run func(ctx context.Context, message *models.Message) error) *Repository_CreateMessage_Call {
	_c.Call.Return(run)
	return _c
}

// CreateProject provides a mock function for the type Repository
func (_mock *Repository) CreateProject(ctx context.Context, project *models.Project) error {
	ret := _mock.Called(ctx, project)

	if len(ret) == 0 {
		panic("no return value specified for CreateProject")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *models.Project) error); ok {
		r0 = returnFunc(ctx, project)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// Repository_CreateProject_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateProject'
type Repository_CreateProject_Call struct {
	*mock.Call
}

// CreateProject is a helper method to define mock.On call
//   - ctx context.Context
//   - project *models.Project
func (_e *Repository_Expecter) CreateProject(ctx interface{}, project interface{}) *Repository_CreateProject_Call {
	return &Repository_CreateProject_Call{Call: _e.mock.On("CreateProject", ctx, project)}
}

func (_c *Repository_CreateProject_Call) Run(run func(ctx context.Context, project *models.Project)) *Repository_CreateProject_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *models.Project
		if args[1] != nil {
			arg1 = args[1].(*models.Project)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *Repository_CreateProject_Call) Return(err error) *Repository_CreateProject_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *Repository_CreateProject_Call) RunAndReturn(run func(ctx context.Context, project *models.Project) error) *Repository_CreateProject_Call {
	_c.Call.Return(run)
	return _c
}

// CreateRule provides a mock function for the type Repository
func (_mock *Repository) CreateRule(ctx context.Context, rule *models.ForwardRule) error {
	ret := _mock.Called(ctx, rule)

	if len(ret) == 0 {
		panic("no return value specified for CreateRule")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *models.ForwardRule) error); ok {
		r0 = returnFunc(ctx, rule)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// Repository_CreateRule_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateRule'
type Repository_CreateRule_Call struct {
	*mock.Call
}

// CreateRule is a helper method to define mock.On call
//   - ctx context.Context
//   - rule *models.ForwardRule
func (_e *Repository_Expecter) CreateRule(ctx interface{}, rule interface{}) *Repository_CreateRule_Call {
	return &Repository_CreateRule_Call{Call: _e.mock.On("CreateRule", ctx, rule)}
}

func (_c *Repository_CreateRule_Call) Run(run func(ctx context.Context, rule *models.ForwardRule)) *Repository_CreateRule_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *models.ForwardRule
		if args[1] != nil {
			arg1 = args[1].(*models.ForwardRule)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *Repository_CreateRule_Call) Return(err error) *Repository_CreateRule_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *Repository_CreateRule_Call) RunAndReturn(run func(ctx context.Context, rule *models.ForwardRule) error) *Repository_CreateRule_Call {
	_c.Call.Return(run)
	return _c
}

// CreateToken provides a mock function for the type Repository
func (_mock *Repository) CreateToken(ctx context.Context, token *models.Token) error {
	ret := _mock.Called(ctx, token)

	if len(ret) == 0 {
		panic("no return value specified for CreateToken")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *models.Token) error); ok {
		r0 = returnFunc(ctx, token)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// Repository_CreateToken_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateToken'
type Repository_CreateToken_Call struct {
	*mock.Call
}

// CreateToken is a helper method to define mock.On call
//   - ctx context.Context
//   - token *models.Token
func (_e *Repository_Expecter) CreateToken(ctx interface{}, token interface{}) *Repository_CreateToken_Call {
	return &Repository_CreateToken_Call{Call: _e.mock.On("CreateToken", ctx, token)}
}

func (_c *Repository_CreateToken_Call) Run(run func(ctx context.Context, token *models.Token)) *Repository_CreateToken_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *models.Token
		if args[1] != nil {
			arg1 = args[1].(*models.Token)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *Repository_CreateToken_Call) Return(err error) *Repository_CreateToken_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *Repository_CreateToken_Call) RunAndReturn(run func(ctx context.Context, token *models.Token) error) *Repository_CreateToken_Call {
	_c.Call.Return(run)
	return _c
}

// CreateUser provides a mock function for the type Repository
func (_mock *Repository) CreateUser(ctx context.Context, user *models.User) error {
	ret := _mock.Called(ctx, user)

	if len(ret) == 0 {
		panic("no return value specified for CreateUser")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *models.User) error); ok {
		r0 = returnFunc(ctx, user)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// Repository_CreateUser_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateUser'
type Repository_CreateUser_Call struct {
	*mock.Call
}

// CreateUser is a helper method to define mock.On call
//   - ctx context.Context
//   - user *models.User
func (_e *Repository_Expecter) CreateUser(ctx interface{}, user interface{}) *Repository_CreateUser_Call {
	return &Repository_CreateUser_Call{Call: _e.mock.On("CreateUser", ctx, user)}
}

func (_c *Repository_CreateUser_Call) Run(run func(ctx context.Context, user *models.User)) *Repository_CreateUser_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *models.User
		if args[1] != nil {
			arg1 = args[1].(*models.User)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *Repository_CreateUser_Call) Return(err error) *Repository_CreateUser_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *Repository_CreateUser_Call) RunAndReturn(run func(ctx context.Context, user *models.User) error) *Repository_CreateUser_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteInbox provides a mock function for the type Repository
func (_mock *Repository) DeleteInbox(ctx context.Context, id string) error {
	ret := _mock.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for DeleteInbox")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) error); ok {
		r0 = returnFunc(ctx, id)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// Repository_DeleteInbox_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteInbox'
type Repository_DeleteInbox_Call struct {
	*mock.Call
}

// DeleteInbox is a helper method to define mock.On call
//   - ctx context.Context
//   - id string
func (_e *Repository_Expecter) DeleteInbox(ctx interface{}, id interface{}) *Repository_DeleteInbox_Call {
	return &Repository_DeleteInbox_Call{Call: _e.mock.On("DeleteInbox", ctx, id)}
}

func (_c *Repository_DeleteInbox_Call) Run(run func(ctx context.Context, id string)) *Repository_DeleteInbox_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *Repository_DeleteInbox_Call) Return(err error) *Repository_DeleteInbox_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *Repository_DeleteInbox_Call) RunAndReturn(run func(ctx context.Context, id string) error) *Repository_DeleteInbox_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteMessage provides a mock function for the type Repository
func (_mock *Repository) DeleteMessage(ctx context.Context, messageID string) error {
	ret := _mock.Called(ctx, messageID)

	if len(ret) == 0 {
		panic("no return value specified for DeleteMessage")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) error); ok {
		r0 = returnFunc(ctx, messageID)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// Repository_DeleteMessage_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteMessage'
type Repository_DeleteMessage_Call struct {
	*mock.Call
}

// DeleteMessage is a helper method to define mock.On call
//   - ctx context.Context
//   - messageID string
func (_e *Repository_Expecter) DeleteMessage(ctx interface{}, messageID interface{}) *Repository_DeleteMessage_Call {
	return &Repository_DeleteMessage_Call{Call: _e.mock.On("DeleteMessage", ctx, messageID)}
}

func (_c *Repository_DeleteMessage_Call) Run(run func(ctx context.Context, messageID string)) *Repository_DeleteMessage_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *Repository_DeleteMessage_Call) Return(err error) *Repository_DeleteMessage_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *Repository_DeleteMessage_Call) RunAndReturn(run func(ctx context.Context, messageID string) error) *Repository_DeleteMessage_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteProject provides a mock function for the type Repository
func (_mock *Repository) DeleteProject(ctx context.Context, id string) error {
	ret := _mock.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for DeleteProject")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) error); ok {
		r0 = returnFunc(ctx, id)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// Repository_DeleteProject_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteProject'
type Repository_DeleteProject_Call struct {
	*mock.Call
}

// DeleteProject is a helper method to define mock.On call
//   - ctx context.Context
//   - id string
func (_e *Repository_Expecter) DeleteProject(ctx interface{}, id interface{}) *Repository_DeleteProject_Call {
	return &Repository_DeleteProject_Call{Call: _e.mock.On("DeleteProject", ctx, id)}
}

func (_c *Repository_DeleteProject_Call) Run(run func(ctx context.Context, id string)) *Repository_DeleteProject_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *Repository_DeleteProject_Call) Return(err error) *Repository_DeleteProject_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *Repository_DeleteProject_Call) RunAndReturn(run func(ctx context.Context, id string) error) *Repository_DeleteProject_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteRule provides a mock function for the type Repository
func (_mock *Repository) DeleteRule(ctx context.Context, id string) error {
	ret := _mock.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for DeleteRule")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) error); ok {
		r0 = returnFunc(ctx, id)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// Repository_DeleteRule_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteRule'
type Repository_DeleteRule_Call struct {
	*mock.Call
}

// DeleteRule is a helper method to define mock.On call
//   - ctx context.Context
//   - id string
func (_e *Repository_Expecter) DeleteRule(ctx interface{}, id interface{}) *Repository_DeleteRule_Call {
	return &Repository_DeleteRule_Call{Call: _e.mock.On("DeleteRule", ctx, id)}
}

func (_c *Repository_DeleteRule_Call) Run(run func(ctx context.Context, id string)) *Repository_DeleteRule_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *Repository_DeleteRule_Call) Return(err error) *Repository_DeleteRule_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *Repository_DeleteRule_Call) RunAndReturn(run func(ctx context.Context, id string) error) *Repository_DeleteRule_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteToken provides a mock function for the type Repository
func (_mock *Repository) DeleteToken(ctx context.Context, tokenID string) error {
	ret := _mock.Called(ctx, tokenID)

	if len(ret) == 0 {
		panic("no return value specified for DeleteToken")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) error); ok {
		r0 = returnFunc(ctx, tokenID)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// Repository_DeleteToken_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteToken'
type Repository_DeleteToken_Call struct {
	*mock.Call
}

// DeleteToken is a helper method to define mock.On call
//   - ctx context.Context
//   - tokenID string
func (_e *Repository_Expecter) DeleteToken(ctx interface{}, tokenID interface{}) *Repository_DeleteToken_Call {
	return &Repository_DeleteToken_Call{Call: _e.mock.On("DeleteToken", ctx, tokenID)}
}

func (_c *Repository_DeleteToken_Call) Run(run func(ctx context.Context, tokenID string)) *Repository_DeleteToken_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *Repository_DeleteToken_Call) Return(err error) *Repository_DeleteToken_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *Repository_DeleteToken_Call) RunAndReturn(run func(ctx context.Context, tokenID string) error) *Repository_DeleteToken_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteUser provides a mock function for the type Repository
func (_mock *Repository) DeleteUser(ctx context.Context, userId string) error {
	ret := _mock.Called(ctx, userId)

	if len(ret) == 0 {
		panic("no return value specified for DeleteUser")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) error); ok {
		r0 = returnFunc(ctx, userId)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// Repository_DeleteUser_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteUser'
type Repository_DeleteUser_Call struct {
	*mock.Call
}

// DeleteUser is a helper method to define mock.On call
//   - ctx context.Context
//   - userId string
func (_e *Repository_Expecter) DeleteUser(ctx interface{}, userId interface{}) *Repository_DeleteUser_Call {
	return &Repository_DeleteUser_Call{Call: _e.mock.On("DeleteUser", ctx, userId)}
}

func (_c *Repository_DeleteUser_Call) Run(run func(ctx context.Context, userId string)) *Repository_DeleteUser_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *Repository_DeleteUser_Call) Return(err error) *Repository_DeleteUser_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *Repository_DeleteUser_Call) RunAndReturn(run func(ctx context.Context, userId string) error) *Repository_DeleteUser_Call {
	_c.Call.Return(run)
	return _c
}

// GetAllMessageUIDsForInbox provides a mock function for the type Repository
func (_mock *Repository) GetAllMessageUIDsForInbox(ctx context.Context, inboxID string) ([]uint32, error) {
	ret := _mock.Called(ctx, inboxID)

	if len(ret) == 0 {
		panic("no return value specified for GetAllMessageUIDsForInbox")
	}

	var r0 []uint32
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) ([]uint32, error)); ok {
		return returnFunc(ctx, inboxID)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) []uint32); ok {
		r0 = returnFunc(ctx, inboxID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]uint32)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = returnFunc(ctx, inboxID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Repository_GetAllMessageUIDsForInbox_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetAllMessageUIDsForInbox'
type Repository_GetAllMessageUIDsForInbox_Call struct {
	*mock.Call
}

// GetAllMessageUIDsForInbox is a helper method to define mock.On call
//   - ctx context.Context
//   - inboxID string
func (_e *Repository_Expecter) GetAllMessageUIDsForInbox(ctx interface{}, inboxID interface{}) *Repository_GetAllMessageUIDsForInbox_Call {
	return &Repository_GetAllMessageUIDsForInbox_Call{Call: _e.mock.On("GetAllMessageUIDsForInbox", ctx, inboxID)}
}

func (_c *Repository_GetAllMessageUIDsForInbox_Call) Run(run func(ctx context.Context, inboxID string)) *Repository_GetAllMessageUIDsForInbox_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *Repository_GetAllMessageUIDsForInbox_Call) Return(uint32s []uint32, err error) *Repository_GetAllMessageUIDsForInbox_Call {
	_c.Call.Return(uint32s, err)
	return _c
}

func (_c *Repository_GetAllMessageUIDsForInbox_Call) RunAndReturn(run func(ctx context.Context, inboxID string) ([]uint32, error)) *Repository_GetAllMessageUIDsForInbox_Call {
	_c.Call.Return(run)
	return _c
}

// GetAllMessageUIDsForInboxIncludingDeleted provides a mock function for the type Repository
func (_mock *Repository) GetAllMessageUIDsForInboxIncludingDeleted(ctx context.Context, inboxID string) ([]uint32, error) {
	ret := _mock.Called(ctx, inboxID)

	if len(ret) == 0 {
		panic("no return value specified for GetAllMessageUIDsForInboxIncludingDeleted")
	}

	var r0 []uint32
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) ([]uint32, error)); ok {
		return returnFunc(ctx, inboxID)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) []uint32); ok {
		r0 = returnFunc(ctx, inboxID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]uint32)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = returnFunc(ctx, inboxID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Repository_GetAllMessageUIDsForInboxIncludingDeleted_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetAllMessageUIDsForInboxIncludingDeleted'
type Repository_GetAllMessageUIDsForInboxIncludingDeleted_Call struct {
	*mock.Call
}

// GetAllMessageUIDsForInboxIncludingDeleted is a helper method to define mock.On call
//   - ctx context.Context
//   - inboxID string
func (_e *Repository_Expecter) GetAllMessageUIDsForInboxIncludingDeleted(ctx interface{}, inboxID interface{}) *Repository_GetAllMessageUIDsForInboxIncludingDeleted_Call {
	return &Repository_GetAllMessageUIDsForInboxIncludingDeleted_Call{Call: _e.mock.On("GetAllMessageUIDsForInboxIncludingDeleted", ctx, inboxID)}
}

func (_c *Repository_GetAllMessageUIDsForInboxIncludingDeleted_Call) Run(run func(ctx context.Context, inboxID string)) *Repository_GetAllMessageUIDsForInboxIncludingDeleted_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *Repository_GetAllMessageUIDsForInboxIncludingDeleted_Call) Return(uint32s []uint32, err error) *Repository_GetAllMessageUIDsForInboxIncludingDeleted_Call {
	_c.Call.Return(uint32s, err)
	return _c
}

func (_c *Repository_GetAllMessageUIDsForInboxIncludingDeleted_Call) RunAndReturn(run func(ctx context.Context, inboxID string) ([]uint32, error)) *Repository_GetAllMessageUIDsForInboxIncludingDeleted_Call {
	_c.Call.Return(run)
	return _c
}

// GetInbox provides a mock function for the type Repository
func (_mock *Repository) GetInbox(ctx context.Context, id string) (*models.Inbox, error) {
	ret := _mock.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for GetInbox")
	}

	var r0 *models.Inbox
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) (*models.Inbox, error)); ok {
		return returnFunc(ctx, id)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) *models.Inbox); ok {
		r0 = returnFunc(ctx, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*models.Inbox)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = returnFunc(ctx, id)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Repository_GetInbox_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetInbox'
type Repository_GetInbox_Call struct {
	*mock.Call
}

// GetInbox is a helper method to define mock.On call
//   - ctx context.Context
//   - id string
func (_e *Repository_Expecter) GetInbox(ctx interface{}, id interface{}) *Repository_GetInbox_Call {
	return &Repository_GetInbox_Call{Call: _e.mock.On("GetInbox", ctx, id)}
}

func (_c *Repository_GetInbox_Call) Run(run func(ctx context.Context, id string)) *Repository_GetInbox_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *Repository_GetInbox_Call) Return(inbox *models.Inbox, err error) *Repository_GetInbox_Call {
	_c.Call.Return(inbox, err)
	return _c
}

func (_c *Repository_GetInbox_Call) RunAndReturn(run func(ctx context.Context, id string) (*models.Inbox, error)) *Repository_GetInbox_Call {
	_c.Call.Return(run)
	return _c
}

// GetInboxByEmail provides a mock function for the type Repository
func (_mock *Repository) GetInboxByEmail(ctx context.Context, email string) (*models.Inbox, error) {
	ret := _mock.Called(ctx, email)

	if len(ret) == 0 {
		panic("no return value specified for GetInboxByEmail")
	}

	var r0 *models.Inbox
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) (*models.Inbox, error)); ok {
		return returnFunc(ctx, email)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) *models.Inbox); ok {
		r0 = returnFunc(ctx, email)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*models.Inbox)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = returnFunc(ctx, email)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Repository_GetInboxByEmail_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetInboxByEmail'
type Repository_GetInboxByEmail_Call struct {
	*mock.Call
}

// GetInboxByEmail is a helper method to define mock.On call
//   - ctx context.Context
//   - email string
func (_e *Repository_Expecter) GetInboxByEmail(ctx interface{}, email interface{}) *Repository_GetInboxByEmail_Call {
	return &Repository_GetInboxByEmail_Call{Call: _e.mock.On("GetInboxByEmail", ctx, email)}
}

func (_c *Repository_GetInboxByEmail_Call) Run(run func(ctx context.Context, email string)) *Repository_GetInboxByEmail_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *Repository_GetInboxByEmail_Call) Return(inbox *models.Inbox, err error) *Repository_GetInboxByEmail_Call {
	_c.Call.Return(inbox, err)
	return _c
}

func (_c *Repository_GetInboxByEmail_Call) RunAndReturn(run func(ctx context.Context, email string) (*models.Inbox, error)) *Repository_GetInboxByEmail_Call {
	_c.Call.Return(run)
	return _c
}

// GetInboxByEmailAndUser provides a mock function for the type Repository
func (_mock *Repository) GetInboxByEmailAndUser(ctx context.Context, email string, userID string) (*models.Inbox, error) {
	ret := _mock.Called(ctx, email, userID)

	if len(ret) == 0 {
		panic("no return value specified for GetInboxByEmailAndUser")
	}

	var r0 *models.Inbox
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, string) (*models.Inbox, error)); ok {
		return returnFunc(ctx, email, userID)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, string) *models.Inbox); ok {
		r0 = returnFunc(ctx, email, userID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*models.Inbox)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string, string) error); ok {
		r1 = returnFunc(ctx, email, userID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Repository_GetInboxByEmailAndUser_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetInboxByEmailAndUser'
type Repository_GetInboxByEmailAndUser_Call struct {
	*mock.Call
}

// GetInboxByEmailAndUser is a helper method to define mock.On call
//   - ctx context.Context
//   - email string
//   - userID string
func (_e *Repository_Expecter) GetInboxByEmailAndUser(ctx interface{}, email interface{}, userID interface{}) *Repository_GetInboxByEmailAndUser_Call {
	return &Repository_GetInboxByEmailAndUser_Call{Call: _e.mock.On("GetInboxByEmailAndUser", ctx, email, userID)}
}

func (_c *Repository_GetInboxByEmailAndUser_Call) Run(run func(ctx context.Context, email string, userID string)) *Repository_GetInboxByEmailAndUser_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 string
		if args[2] != nil {
			arg2 = args[2].(string)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *Repository_GetInboxByEmailAndUser_Call) Return(inbox *models.Inbox, err error) *Repository_GetInboxByEmailAndUser_Call {
	_c.Call.Return(inbox, err)
	return _c
}

func (_c *Repository_GetInboxByEmailAndUser_Call) RunAndReturn(run func(ctx context.Context, email string, userID string) (*models.Inbox, error)) *Repository_GetInboxByEmailAndUser_Call {
	_c.Call.Return(run)
	return _c
}

// GetMaxMessageUID provides a mock function for the type Repository
func (_mock *Repository) GetMaxMessageUID(ctx context.Context, inboxID string) (uint32, error) {
	ret := _mock.Called(ctx, inboxID)

	if len(ret) == 0 {
		panic("no return value specified for GetMaxMessageUID")
	}

	var r0 uint32
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) (uint32, error)); ok {
		return returnFunc(ctx, inboxID)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) uint32); ok {
		r0 = returnFunc(ctx, inboxID)
	} else {
		r0 = ret.Get(0).(uint32)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = returnFunc(ctx, inboxID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Repository_GetMaxMessageUID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetMaxMessageUID'
type Repository_GetMaxMessageUID_Call struct {
	*mock.Call
}

// GetMaxMessageUID is a helper method to define mock.On call
//   - ctx context.Context
//   - inboxID string
func (_e *Repository_Expecter) GetMaxMessageUID(ctx interface{}, inboxID interface{}) *Repository_GetMaxMessageUID_Call {
	return &Repository_GetMaxMessageUID_Call{Call: _e.mock.On("GetMaxMessageUID", ctx, inboxID)}
}

func (_c *Repository_GetMaxMessageUID_Call) Run(run func(ctx context.Context, inboxID string)) *Repository_GetMaxMessageUID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *Repository_GetMaxMessageUID_Call) Return(v uint32, err error) *Repository_GetMaxMessageUID_Call {
	_c.Call.Return(v, err)
	return _c
}

func (_c *Repository_GetMaxMessageUID_Call) RunAndReturn(run func(ctx context.Context, inboxID string) (uint32, error)) *Repository_GetMaxMessageUID_Call {
	_c.Call.Return(run)
	return _c
}

// GetMessage provides a mock function for the type Repository
func (_mock *Repository) GetMessage(ctx context.Context, id string) (*models.Message, error) {
	ret := _mock.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for GetMessage")
	}

	var r0 *models.Message
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) (*models.Message, error)); ok {
		return returnFunc(ctx, id)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) *models.Message); ok {
		r0 = returnFunc(ctx, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*models.Message)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = returnFunc(ctx, id)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Repository_GetMessage_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetMessage'
type Repository_GetMessage_Call struct {
	*mock.Call
}

// GetMessage is a helper method to define mock.On call
//   - ctx context.Context
//   - id string
func (_e *Repository_Expecter) GetMessage(ctx interface{}, id interface{}) *Repository_GetMessage_Call {
	return &Repository_GetMessage_Call{Call: _e.mock.On("GetMessage", ctx, id)}
}

func (_c *Repository_GetMessage_Call) Run(run func(ctx context.Context, id string)) *Repository_GetMessage_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *Repository_GetMessage_Call) Return(message *models.Message, err error) *Repository_GetMessage_Call {
	_c.Call.Return(message, err)
	return _c
}

func (_c *Repository_GetMessage_Call) RunAndReturn(run func(ctx context.Context, id string) (*models.Message, error)) *Repository_GetMessage_Call {
	_c.Call.Return(run)
	return _c
}

// GetMessageIDFromUID provides a mock function for the type Repository
func (_mock *Repository) GetMessageIDFromUID(ctx context.Context, inboxID string, uid uint32) (string, error) {
	ret := _mock.Called(ctx, inboxID, uid)

	if len(ret) == 0 {
		panic("no return value specified for GetMessageIDFromUID")
	}

	var r0 string
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, uint32) (string, error)); ok {
		return returnFunc(ctx, inboxID, uid)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, uint32) string); ok {
		r0 = returnFunc(ctx, inboxID, uid)
	} else {
		r0 = ret.Get(0).(string)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string, uint32) error); ok {
		r1 = returnFunc(ctx, inboxID, uid)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Repository_GetMessageIDFromUID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetMessageIDFromUID'
type Repository_GetMessageIDFromUID_Call struct {
	*mock.Call
}

// GetMessageIDFromUID is a helper method to define mock.On call
//   - ctx context.Context
//   - inboxID string
//   - uid uint32
func (_e *Repository_Expecter) GetMessageIDFromUID(ctx interface{}, inboxID interface{}, uid interface{}) *Repository_GetMessageIDFromUID_Call {
	return &Repository_GetMessageIDFromUID_Call{Call: _e.mock.On("GetMessageIDFromUID", ctx, inboxID, uid)}
}

func (_c *Repository_GetMessageIDFromUID_Call) Run(run func(ctx context.Context, inboxID string, uid uint32)) *Repository_GetMessageIDFromUID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 uint32
		if args[2] != nil {
			arg2 = args[2].(uint32)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *Repository_GetMessageIDFromUID_Call) Return(s string, err error) *Repository_GetMessageIDFromUID_Call {
	_c.Call.Return(s, err)
	return _c
}

func (_c *Repository_GetMessageIDFromUID_Call) RunAndReturn(run func(ctx context.Context, inboxID string, uid uint32) (string, error)) *Repository_GetMessageIDFromUID_Call {
	_c.Call.Return(run)
	return _c
}

// GetMessagesByUIDs provides a mock function for the type Repository
func (_mock *Repository) GetMessagesByUIDs(ctx context.Context, inboxID string, uids []uint32) ([]*models.Message, error) {
	ret := _mock.Called(ctx, inboxID, uids)

	if len(ret) == 0 {
		panic("no return value specified for GetMessagesByUIDs")
	}

	var r0 []*models.Message
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, []uint32) ([]*models.Message, error)); ok {
		return returnFunc(ctx, inboxID, uids)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, []uint32) []*models.Message); ok {
		r0 = returnFunc(ctx, inboxID, uids)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*models.Message)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string, []uint32) error); ok {
		r1 = returnFunc(ctx, inboxID, uids)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Repository_GetMessagesByUIDs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetMessagesByUIDs'
type Repository_GetMessagesByUIDs_Call struct {
	*mock.Call
}

// GetMessagesByUIDs is a helper method to define mock.On call
//   - ctx context.Context
//   - inboxID string
//   - uids []uint32
func (_e *Repository_Expecter) GetMessagesByUIDs(ctx interface{}, inboxID interface{}, uids interface{}) *Repository_GetMessagesByUIDs_Call {
	return &Repository_GetMessagesByUIDs_Call{Call: _e.mock.On("GetMessagesByUIDs", ctx, inboxID, uids)}
}

func (_c *Repository_GetMessagesByUIDs_Call) Run(run func(ctx context.Context, inboxID string, uids []uint32)) *Repository_GetMessagesByUIDs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 []uint32
		if args[2] != nil {
			arg2 = args[2].([]uint32)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *Repository_GetMessagesByUIDs_Call) Return(messages []*models.Message, err error) *Repository_GetMessagesByUIDs_Call {
	_c.Call.Return(messages, err)
	return _c
}

func (_c *Repository_GetMessagesByUIDs_Call) RunAndReturn(run func(ctx context.Context, inboxID string, uids []uint32) ([]*models.Message, error)) *Repository_GetMessagesByUIDs_Call {
	_c.Call.Return(run)
	return _c
}

// GetProject provides a mock function for the type Repository
func (_mock *Repository) GetProject(ctx context.Context, id string) (*models.Project, error) {
	ret := _mock.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for GetProject")
	}

	var r0 *models.Project
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) (*models.Project, error)); ok {
		return returnFunc(ctx, id)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) *models.Project); ok {
		r0 = returnFunc(ctx, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*models.Project)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = returnFunc(ctx, id)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Repository_GetProject_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetProject'
type Repository_GetProject_Call struct {
	*mock.Call
}

// GetProject is a helper method to define mock.On call
//   - ctx context.Context
//   - id string
func (_e *Repository_Expecter) GetProject(ctx interface{}, id interface{}) *Repository_GetProject_Call {
	return &Repository_GetProject_Call{Call: _e.mock.On("GetProject", ctx, id)}
}

func (_c *Repository_GetProject_Call) Run(run func(ctx context.Context, id string)) *Repository_GetProject_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *Repository_GetProject_Call) Return(project *models.Project, err error) *Repository_GetProject_Call {
	_c.Call.Return(project, err)
	return _c
}

func (_c *Repository_GetProject_Call) RunAndReturn(run func(ctx context.Context, id string) (*models.Project, error)) *Repository_GetProject_Call {
	_c.Call.Return(run)
	return _c
}

// GetRule provides a mock function for the type Repository
func (_mock *Repository) GetRule(ctx context.Context, id string) (*models.ForwardRule, error) {
	ret := _mock.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for GetRule")
	}

	var r0 *models.ForwardRule
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) (*models.ForwardRule, error)); ok {
		return returnFunc(ctx, id)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) *models.ForwardRule); ok {
		r0 = returnFunc(ctx, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*models.ForwardRule)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = returnFunc(ctx, id)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Repository_GetRule_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetRule'
type Repository_GetRule_Call struct {
	*mock.Call
}

// GetRule is a helper method to define mock.On call
//   - ctx context.Context
//   - id string
func (_e *Repository_Expecter) GetRule(ctx interface{}, id interface{}) *Repository_GetRule_Call {
	return &Repository_GetRule_Call{Call: _e.mock.On("GetRule", ctx, id)}
}

func (_c *Repository_GetRule_Call) Run(run func(ctx context.Context, id string)) *Repository_GetRule_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *Repository_GetRule_Call) Return(forwardRule *models.ForwardRule, err error) *Repository_GetRule_Call {
	_c.Call.Return(forwardRule, err)
	return _c
}

func (_c *Repository_GetRule_Call) RunAndReturn(run func(ctx context.Context, id string) (*models.ForwardRule, error)) *Repository_GetRule_Call {
	_c.Call.Return(run)
	return _c
}

// GetTokenByUser provides a mock function for the type Repository
func (_mock *Repository) GetTokenByUser(ctx context.Context, userID string, tokenID string) (*models.Token, error) {
	ret := _mock.Called(ctx, userID, tokenID)

	if len(ret) == 0 {
		panic("no return value specified for GetTokenByUser")
	}

	var r0 *models.Token
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, string) (*models.Token, error)); ok {
		return returnFunc(ctx, userID, tokenID)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, string) *models.Token); ok {
		r0 = returnFunc(ctx, userID, tokenID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*models.Token)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string, string) error); ok {
		r1 = returnFunc(ctx, userID, tokenID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Repository_GetTokenByUser_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetTokenByUser'
type Repository_GetTokenByUser_Call struct {
	*mock.Call
}

// GetTokenByUser is a helper method to define mock.On call
//   - ctx context.Context
//   - userID string
//   - tokenID string
func (_e *Repository_Expecter) GetTokenByUser(ctx interface{}, userID interface{}, tokenID interface{}) *Repository_GetTokenByUser_Call {
	return &Repository_GetTokenByUser_Call{Call: _e.mock.On("GetTokenByUser", ctx, userID, tokenID)}
}

func (_c *Repository_GetTokenByUser_Call) Run(run func(ctx context.Context, userID string, tokenID string)) *Repository_GetTokenByUser_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 string
		if args[2] != nil {
			arg2 = args[2].(string)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *Repository_GetTokenByUser_Call) Return(token *models.Token, err error) *Repository_GetTokenByUser_Call {
	_c.Call.Return(token, err)
	return _c
}

func (_c *Repository_GetTokenByUser_Call) RunAndReturn(run func(ctx context.Context, userID string, tokenID string) (*models.Token, error)) *Repository_GetTokenByUser_Call {
	_c.Call.Return(run)
	return _c
}

// GetTokenByValue provides a mock function for the type Repository
func (_mock *Repository) GetTokenByValue(ctx context.Context, tokenValue string) (*models.Token, error) {
	ret := _mock.Called(ctx, tokenValue)

	if len(ret) == 0 {
		panic("no return value specified for GetTokenByValue")
	}

	var r0 *models.Token
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) (*models.Token, error)); ok {
		return returnFunc(ctx, tokenValue)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) *models.Token); ok {
		r0 = returnFunc(ctx, tokenValue)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*models.Token)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = returnFunc(ctx, tokenValue)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Repository_GetTokenByValue_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetTokenByValue'
type Repository_GetTokenByValue_Call struct {
	*mock.Call
}

// GetTokenByValue is a helper method to define mock.On call
//   - ctx context.Context
//   - tokenValue string
func (_e *Repository_Expecter) GetTokenByValue(ctx interface{}, tokenValue interface{}) *Repository_GetTokenByValue_Call {
	return &Repository_GetTokenByValue_Call{Call: _e.mock.On("GetTokenByValue", ctx, tokenValue)}
}

func (_c *Repository_GetTokenByValue_Call) Run(run func(ctx context.Context, tokenValue string)) *Repository_GetTokenByValue_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *Repository_GetTokenByValue_Call) Return(token *models.Token, err error) *Repository_GetTokenByValue_Call {
	_c.Call.Return(token, err)
	return _c
}

func (_c *Repository_GetTokenByValue_Call) RunAndReturn(run func(ctx context.Context, tokenValue string) (*models.Token, error)) *Repository_GetTokenByValue_Call {
	_c.Call.Return(run)
	return _c
}

// GetUser provides a mock function for the type Repository
func (_mock *Repository) GetUser(ctx context.Context, id string) (*models.User, error) {
	ret := _mock.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for GetUser")
	}

	var r0 *models.User
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) (*models.User, error)); ok {
		return returnFunc(ctx, id)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) *models.User); ok {
		r0 = returnFunc(ctx, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*models.User)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = returnFunc(ctx, id)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Repository_GetUser_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetUser'
type Repository_GetUser_Call struct {
	*mock.Call
}

// GetUser is a helper method to define mock.On call
//   - ctx context.Context
//   - id string
func (_e *Repository_Expecter) GetUser(ctx interface{}, id interface{}) *Repository_GetUser_Call {
	return &Repository_GetUser_Call{Call: _e.mock.On("GetUser", ctx, id)}
}

func (_c *Repository_GetUser_Call) Run(run func(ctx context.Context, id string)) *Repository_GetUser_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *Repository_GetUser_Call) Return(user *models.User, err error) *Repository_GetUser_Call {
	_c.Call.Return(user, err)
	return _c
}

func (_c *Repository_GetUser_Call) RunAndReturn(run func(ctx context.Context, id string) (*models.User, error)) *Repository_GetUser_Call {
	_c.Call.Return(run)
	return _c
}

// GetUserByEmail provides a mock function for the type Repository
func (_mock *Repository) GetUserByEmail(ctx context.Context, email string) (*models.User, error) {
	ret := _mock.Called(ctx, email)

	if len(ret) == 0 {
		panic("no return value specified for GetUserByEmail")
	}

	var r0 *models.User
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) (*models.User, error)); ok {
		return returnFunc(ctx, email)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) *models.User); ok {
		r0 = returnFunc(ctx, email)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*models.User)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = returnFunc(ctx, email)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Repository_GetUserByEmail_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetUserByEmail'
type Repository_GetUserByEmail_Call struct {
	*mock.Call
}

// GetUserByEmail is a helper method to define mock.On call
//   - ctx context.Context
//   - email string
func (_e *Repository_Expecter) GetUserByEmail(ctx interface{}, email interface{}) *Repository_GetUserByEmail_Call {
	return &Repository_GetUserByEmail_Call{Call: _e.mock.On("GetUserByEmail", ctx, email)}
}

func (_c *Repository_GetUserByEmail_Call) Run(run func(ctx context.Context, email string)) *Repository_GetUserByEmail_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *Repository_GetUserByEmail_Call) Return(user *models.User, err error) *Repository_GetUserByEmail_Call {
	_c.Call.Return(user, err)
	return _c
}

func (_c *Repository_GetUserByEmail_Call) RunAndReturn(run func(ctx context.Context, email string) (*models.User, error)) *Repository_GetUserByEmail_Call {
	_c.Call.Return(run)
	return _c
}

// GetUserByUsername provides a mock function for the type Repository
func (_mock *Repository) GetUserByUsername(ctx context.Context, username string) (*models.User, error) {
	ret := _mock.Called(ctx, username)

	if len(ret) == 0 {
		panic("no return value specified for GetUserByUsername")
	}

	var r0 *models.User
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) (*models.User, error)); ok {
		return returnFunc(ctx, username)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) *models.User); ok {
		r0 = returnFunc(ctx, username)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*models.User)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = returnFunc(ctx, username)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Repository_GetUserByUsername_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetUserByUsername'
type Repository_GetUserByUsername_Call struct {
	*mock.Call
}

// GetUserByUsername is a helper method to define mock.On call
//   - ctx context.Context
//   - username string
func (_e *Repository_Expecter) GetUserByUsername(ctx interface{}, username interface{}) *Repository_GetUserByUsername_Call {
	return &Repository_GetUserByUsername_Call{Call: _e.mock.On("GetUserByUsername", ctx, username)}
}

func (_c *Repository_GetUserByUsername_Call) Run(run func(ctx context.Context, username string)) *Repository_GetUserByUsername_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *Repository_GetUserByUsername_Call) Return(user *models.User, err error) *Repository_GetUserByUsername_Call {
	_c.Call.Return(user, err)
	return _c
}

func (_c *Repository_GetUserByUsername_Call) RunAndReturn(run func(ctx context.Context, username string) (*models.User, error)) *Repository_GetUserByUsername_Call {
	_c.Call.Return(run)
	return _c
}

// ListInboxesByProject provides a mock function for the type Repository
func (_mock *Repository) ListInboxesByProject(ctx context.Context, projectID string, limit int, offset int) ([]*models.Inbox, int, error) {
	ret := _mock.Called(ctx, projectID, limit, offset)

	if len(ret) == 0 {
		panic("no return value specified for ListInboxesByProject")
	}

	var r0 []*models.Inbox
	var r1 int
	var r2 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, int, int) ([]*models.Inbox, int, error)); ok {
		return returnFunc(ctx, projectID, limit, offset)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, int, int) []*models.Inbox); ok {
		r0 = returnFunc(ctx, projectID, limit, offset)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*models.Inbox)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string, int, int) int); ok {
		r1 = returnFunc(ctx, projectID, limit, offset)
	} else {
		r1 = ret.Get(1).(int)
	}
	if returnFunc, ok := ret.Get(2).(func(context.Context, string, int, int) error); ok {
		r2 = returnFunc(ctx, projectID, limit, offset)
	} else {
		r2 = ret.Error(2)
	}
	return r0, r1, r2
}

// Repository_ListInboxesByProject_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListInboxesByProject'
type Repository_ListInboxesByProject_Call struct {
	*mock.Call
}

// ListInboxesByProject is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID string
//   - limit int
//   - offset int
func (_e *Repository_Expecter) ListInboxesByProject(ctx interface{}, projectID interface{}, limit interface{}, offset interface{}) *Repository_ListInboxesByProject_Call {
	return &Repository_ListInboxesByProject_Call{Call: _e.mock.On("ListInboxesByProject", ctx, projectID, limit, offset)}
}

func (_c *Repository_ListInboxesByProject_Call) Run(run func(ctx context.Context, projectID string, limit int, offset int)) *Repository_ListInboxesByProject_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 int
		if args[2] != nil {
			arg2 = args[2].(int)
		}
		var arg3 int
		if args[3] != nil {
			arg3 = args[3].(int)
		}
		run(
			arg0,
			arg1,
			arg2,
			arg3,
		)
	})
	return _c
}

func (_c *Repository_ListInboxesByProject_Call) Return(inboxs []*models.Inbox, n int, err error) *Repository_ListInboxesByProject_Call {
	_c.Call.Return(inboxs, n, err)
	return _c
}

func (_c *Repository_ListInboxesByProject_Call) RunAndReturn(run func(ctx context.Context, projectID string, limit int, offset int) ([]*models.Inbox, int, error)) *Repository_ListInboxesByProject_Call {
	_c.Call.Return(run)
	return _c
}

// ListInboxesByUser provides a mock function for the type Repository
func (_mock *Repository) ListInboxesByUser(ctx context.Context, userID string) ([]*models.Inbox, error) {
	ret := _mock.Called(ctx, userID)

	if len(ret) == 0 {
		panic("no return value specified for ListInboxesByUser")
	}

	var r0 []*models.Inbox
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) ([]*models.Inbox, error)); ok {
		return returnFunc(ctx, userID)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) []*models.Inbox); ok {
		r0 = returnFunc(ctx, userID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*models.Inbox)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = returnFunc(ctx, userID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Repository_ListInboxesByUser_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListInboxesByUser'
type Repository_ListInboxesByUser_Call struct {
	*mock.Call
}

// ListInboxesByUser is a helper method to define mock.On call
//   - ctx context.Context
//   - userID string
func (_e *Repository_Expecter) ListInboxesByUser(ctx interface{}, userID interface{}) *Repository_ListInboxesByUser_Call {
	return &Repository_ListInboxesByUser_Call{Call: _e.mock.On("ListInboxesByUser", ctx, userID)}
}

func (_c *Repository_ListInboxesByUser_Call) Run(run func(ctx context.Context, userID string)) *Repository_ListInboxesByUser_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *Repository_ListInboxesByUser_Call) Return(inboxs []*models.Inbox, err error) *Repository_ListInboxesByUser_Call {
	_c.Call.Return(inboxs, err)
	return _c
}

func (_c *Repository_ListInboxesByUser_Call) RunAndReturn(run func(ctx context.Context, userID string) ([]*models.Inbox, error)) *Repository_ListInboxesByUser_Call {
	_c.Call.Return(run)
	return _c
}

// ListMessagesByInbox provides a mock function for the type Repository
func (_mock *Repository) ListMessagesByInbox(ctx context.Context, inboxID string, limit int, offset int) ([]*models.Message, int, error) {
	ret := _mock.Called(ctx, inboxID, limit, offset)

	if len(ret) == 0 {
		panic("no return value specified for ListMessagesByInbox")
	}

	var r0 []*models.Message
	var r1 int
	var r2 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, int, int) ([]*models.Message, int, error)); ok {
		return returnFunc(ctx, inboxID, limit, offset)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, int, int) []*models.Message); ok {
		r0 = returnFunc(ctx, inboxID, limit, offset)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*models.Message)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string, int, int) int); ok {
		r1 = returnFunc(ctx, inboxID, limit, offset)
	} else {
		r1 = ret.Get(1).(int)
	}
	if returnFunc, ok := ret.Get(2).(func(context.Context, string, int, int) error); ok {
		r2 = returnFunc(ctx, inboxID, limit, offset)
	} else {
		r2 = ret.Error(2)
	}
	return r0, r1, r2
}

// Repository_ListMessagesByInbox_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListMessagesByInbox'
type Repository_ListMessagesByInbox_Call struct {
	*mock.Call
}

// ListMessagesByInbox is a helper method to define mock.On call
//   - ctx context.Context
//   - inboxID string
//   - limit int
//   - offset int
func (_e *Repository_Expecter) ListMessagesByInbox(ctx interface{}, inboxID interface{}, limit interface{}, offset interface{}) *Repository_ListMessagesByInbox_Call {
	return &Repository_ListMessagesByInbox_Call{Call: _e.mock.On("ListMessagesByInbox", ctx, inboxID, limit, offset)}
}

func (_c *Repository_ListMessagesByInbox_Call) Run(run func(ctx context.Context, inboxID string, limit int, offset int)) *Repository_ListMessagesByInbox_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 int
		if args[2] != nil {
			arg2 = args[2].(int)
		}
		var arg3 int
		if args[3] != nil {
			arg3 = args[3].(int)
		}
		run(
			arg0,
			arg1,
			arg2,
			arg3,
		)
	})
	return _c
}

func (_c *Repository_ListMessagesByInbox_Call) Return(messages []*models.Message, n int, err error) *Repository_ListMessagesByInbox_Call {
	_c.Call.Return(messages, n, err)
	return _c
}

func (_c *Repository_ListMessagesByInbox_Call) RunAndReturn(run func(ctx context.Context, inboxID string, limit int, offset int) ([]*models.Message, int, error)) *Repository_ListMessagesByInbox_Call {
	_c.Call.Return(run)
	return _c
}

// ListMessagesByInboxWithFilter provides a mock function for the type Repository
func (_mock *Repository) ListMessagesByInboxWithFilter(ctx context.Context, inboxID string, isRead *bool, limit int, offset int) ([]*models.Message, int, error) {
	ret := _mock.Called(ctx, inboxID, isRead, limit, offset)

	if len(ret) == 0 {
		panic("no return value specified for ListMessagesByInboxWithFilter")
	}

	var r0 []*models.Message
	var r1 int
	var r2 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, *bool, int, int) ([]*models.Message, int, error)); ok {
		return returnFunc(ctx, inboxID, isRead, limit, offset)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, *bool, int, int) []*models.Message); ok {
		r0 = returnFunc(ctx, inboxID, isRead, limit, offset)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*models.Message)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string, *bool, int, int) int); ok {
		r1 = returnFunc(ctx, inboxID, isRead, limit, offset)
	} else {
		r1 = ret.Get(1).(int)
	}
	if returnFunc, ok := ret.Get(2).(func(context.Context, string, *bool, int, int) error); ok {
		r2 = returnFunc(ctx, inboxID, isRead, limit, offset)
	} else {
		r2 = ret.Error(2)
	}
	return r0, r1, r2
}

// Repository_ListMessagesByInboxWithFilter_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListMessagesByInboxWithFilter'
type Repository_ListMessagesByInboxWithFilter_Call struct {
	*mock.Call
}

// ListMessagesByInboxWithFilter is a helper method to define mock.On call
//   - ctx context.Context
//   - inboxID string
//   - isRead *bool
//   - limit int
//   - offset int
func (_e *Repository_Expecter) ListMessagesByInboxWithFilter(ctx interface{}, inboxID interface{}, isRead interface{}, limit interface{}, offset interface{}) *Repository_ListMessagesByInboxWithFilter_Call {
	return &Repository_ListMessagesByInboxWithFilter_Call{Call: _e.mock.On("ListMessagesByInboxWithFilter", ctx, inboxID, isRead, limit, offset)}
}

func (_c *Repository_ListMessagesByInboxWithFilter_Call) Run(run func(ctx context.Context, inboxID string, isRead *bool, limit int, offset int)) *Repository_ListMessagesByInboxWithFilter_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 *bool
		if args[2] != nil {
			arg2 = args[2].(*bool)
		}
		var arg3 int
		if args[3] != nil {
			arg3 = args[3].(int)
		}
		var arg4 int
		if args[4] != nil {
			arg4 = args[4].(int)
		}
		run(
			arg0,
			arg1,
			arg2,
			arg3,
			arg4,
		)
	})
	return _c
}

func (_c *Repository_ListMessagesByInboxWithFilter_Call) Return(messages []*models.Message, n int, err error) *Repository_ListMessagesByInboxWithFilter_Call {
	_c.Call.Return(messages, n, err)
	return _c
}

func (_c *Repository_ListMessagesByInboxWithFilter_Call) RunAndReturn(run func(ctx context.Context, inboxID string, isRead *bool, limit int, offset int) ([]*models.Message, int, error)) *Repository_ListMessagesByInboxWithFilter_Call {
	_c.Call.Return(run)
	return _c
}

// ListMessagesByInboxWithFilters provides a mock function for the type Repository
func (_mock *Repository) ListMessagesByInboxWithFilters(ctx context.Context, inboxID string, filters models.MessageFilters, limit int, offset int) ([]*models.Message, int, error) {
	ret := _mock.Called(ctx, inboxID, filters, limit, offset)

	if len(ret) == 0 {
		panic("no return value specified for ListMessagesByInboxWithFilters")
	}

	var r0 []*models.Message
	var r1 int
	var r2 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, models.MessageFilters, int, int) ([]*models.Message, int, error)); ok {
		return returnFunc(ctx, inboxID, filters, limit, offset)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, models.MessageFilters, int, int) []*models.Message); ok {
		r0 = returnFunc(ctx, inboxID, filters, limit, offset)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*models.Message)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string, models.MessageFilters, int, int) int); ok {
		r1 = returnFunc(ctx, inboxID, filters, limit, offset)
	} else {
		r1 = ret.Get(1).(int)
	}
	if returnFunc, ok := ret.Get(2).(func(context.Context, string, models.MessageFilters, int, int) error); ok {
		r2 = returnFunc(ctx, inboxID, filters, limit, offset)
	} else {
		r2 = ret.Error(2)
	}
	return r0, r1, r2
}

// Repository_ListMessagesByInboxWithFilters_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListMessagesByInboxWithFilters'
type Repository_ListMessagesByInboxWithFilters_Call struct {
	*mock.Call
}

// ListMessagesByInboxWithFilters is a helper method to define mock.On call
//   - ctx context.Context
//   - inboxID string
//   - filters models.MessageFilters
//   - limit int
//   - offset int
func (_e *Repository_Expecter) ListMessagesByInboxWithFilters(ctx interface{}, inboxID interface{}, filters interface{}, limit interface{}, offset interface{}) *Repository_ListMessagesByInboxWithFilters_Call {
	return &Repository_ListMessagesByInboxWithFilters_Call{Call: _e.mock.On("ListMessagesByInboxWithFilters", ctx, inboxID, filters, limit, offset)}
}

func (_c *Repository_ListMessagesByInboxWithFilters_Call) Run(run func(ctx context.Context, inboxID string, filters models.MessageFilters, limit int, offset int)) *Repository_ListMessagesByInboxWithFilters_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 models.MessageFilters
		if args[2] != nil {
			arg2 = args[2].(models.MessageFilters)
		}
		var arg3 int
		if args[3] != nil {
			arg3 = args[3].(int)
		}
		var arg4 int
		if args[4] != nil {
			arg4 = args[4].(int)
		}
		run(
			arg0,
			arg1,
			arg2,
			arg3,
			arg4,
		)
	})
	return _c
}

func (_c *Repository_ListMessagesByInboxWithFilters_Call) Return(messages []*models.Message, n int, err error) *Repository_ListMessagesByInboxWithFilters_Call {
	_c.Call.Return(messages, n, err)
	return _c
}

func (_c *Repository_ListMessagesByInboxWithFilters_Call) RunAndReturn(run func(ctx context.Context, inboxID string, filters models.MessageFilters, limit int, offset int) ([]*models.Message, int, error)) *Repository_ListMessagesByInboxWithFilters_Call {
	_c.Call.Return(run)
	return _c
}

// ListProjects provides a mock function for the type Repository
func (_mock *Repository) ListProjects(ctx context.Context, limit int, offset int) ([]*models.Project, int, error) {
	ret := _mock.Called(ctx, limit, offset)

	if len(ret) == 0 {
		panic("no return value specified for ListProjects")
	}

	var r0 []*models.Project
	var r1 int
	var r2 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, int, int) ([]*models.Project, int, error)); ok {
		return returnFunc(ctx, limit, offset)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, int, int) []*models.Project); ok {
		r0 = returnFunc(ctx, limit, offset)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*models.Project)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, int, int) int); ok {
		r1 = returnFunc(ctx, limit, offset)
	} else {
		r1 = ret.Get(1).(int)
	}
	if returnFunc, ok := ret.Get(2).(func(context.Context, int, int) error); ok {
		r2 = returnFunc(ctx, limit, offset)
	} else {
		r2 = ret.Error(2)
	}
	return r0, r1, r2
}

// Repository_ListProjects_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListProjects'
type Repository_ListProjects_Call struct {
	*mock.Call
}

// ListProjects is a helper method to define mock.On call
//   - ctx context.Context
//   - limit int
//   - offset int
func (_e *Repository_Expecter) ListProjects(ctx interface{}, limit interface{}, offset interface{}) *Repository_ListProjects_Call {
	return &Repository_ListProjects_Call{Call: _e.mock.On("ListProjects", ctx, limit, offset)}
}

func (_c *Repository_ListProjects_Call) Run(run func(ctx context.Context, limit int, offset int)) *Repository_ListProjects_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 int
		if args[1] != nil {
			arg1 = args[1].(int)
		}
		var arg2 int
		if args[2] != nil {
			arg2 = args[2].(int)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *Repository_ListProjects_Call) Return(projects []*models.Project, n int, err error) *Repository_ListProjects_Call {
	_c.Call.Return(projects, n, err)
	return _c
}

func (_c *Repository_ListProjects_Call) RunAndReturn(run func(ctx context.Context, limit int, offset int) ([]*models.Project, int, error)) *Repository_ListProjects_Call {
	_c.Call.Return(run)
	return _c
}

// ListProjectsByUser provides a mock function for the type Repository
func (_mock *Repository) ListProjectsByUser(ctx context.Context, userID string, limit int, offset int) ([]*models.Project, int, error) {
	ret := _mock.Called(ctx, userID, limit, offset)

	if len(ret) == 0 {
		panic("no return value specified for ListProjectsByUser")
	}

	var r0 []*models.Project
	var r1 int
	var r2 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, int, int) ([]*models.Project, int, error)); ok {
		return returnFunc(ctx, userID, limit, offset)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, int, int) []*models.Project); ok {
		r0 = returnFunc(ctx, userID, limit, offset)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*models.Project)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string, int, int) int); ok {
		r1 = returnFunc(ctx, userID, limit, offset)
	} else {
		r1 = ret.Get(1).(int)
	}
	if returnFunc, ok := ret.Get(2).(func(context.Context, string, int, int) error); ok {
		r2 = returnFunc(ctx, userID, limit, offset)
	} else {
		r2 = ret.Error(2)
	}
	return r0, r1, r2
}

// Repository_ListProjectsByUser_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListProjectsByUser'
type Repository_ListProjectsByUser_Call struct {
	*mock.Call
}

// ListProjectsByUser is a helper method to define mock.On call
//   - ctx context.Context
//   - userID string
//   - limit int
//   - offset int
func (_e *Repository_Expecter) ListProjectsByUser(ctx interface{}, userID interface{}, limit interface{}, offset interface{}) *Repository_ListProjectsByUser_Call {
	return &Repository_ListProjectsByUser_Call{Call: _e.mock.On("ListProjectsByUser", ctx, userID, limit, offset)}
}

func (_c *Repository_ListProjectsByUser_Call) Run(run func(ctx context.Context, userID string, limit int, offset int)) *Repository_ListProjectsByUser_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 int
		if args[2] != nil {
			arg2 = args[2].(int)
		}
		var arg3 int
		if args[3] != nil {
			arg3 = args[3].(int)
		}
		run(
			arg0,
			arg1,
			arg2,
			arg3,
		)
	})
	return _c
}

func (_c *Repository_ListProjectsByUser_Call) Return(projects []*models.Project, n int, err error) *Repository_ListProjectsByUser_Call {
	_c.Call.Return(projects, n, err)
	return _c
}

func (_c *Repository_ListProjectsByUser_Call) RunAndReturn(run func(ctx context.Context, userID string, limit int, offset int) ([]*models.Project, int, error)) *Repository_ListProjectsByUser_Call {
	_c.Call.Return(run)
	return _c
}

// ListRules provides a mock function for the type Repository
func (_mock *Repository) ListRules(ctx context.Context, limit int, offset int) ([]*models.ForwardRule, int, error) {
	ret := _mock.Called(ctx, limit, offset)

	if len(ret) == 0 {
		panic("no return value specified for ListRules")
	}

	var r0 []*models.ForwardRule
	var r1 int
	var r2 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, int, int) ([]*models.ForwardRule, int, error)); ok {
		return returnFunc(ctx, limit, offset)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, int, int) []*models.ForwardRule); ok {
		r0 = returnFunc(ctx, limit, offset)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*models.ForwardRule)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, int, int) int); ok {
		r1 = returnFunc(ctx, limit, offset)
	} else {
		r1 = ret.Get(1).(int)
	}
	if returnFunc, ok := ret.Get(2).(func(context.Context, int, int) error); ok {
		r2 = returnFunc(ctx, limit, offset)
	} else {
		r2 = ret.Error(2)
	}
	return r0, r1, r2
}

// Repository_ListRules_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListRules'
type Repository_ListRules_Call struct {
	*mock.Call
}

// ListRules is a helper method to define mock.On call
//   - ctx context.Context
//   - limit int
//   - offset int
func (_e *Repository_Expecter) ListRules(ctx interface{}, limit interface{}, offset interface{}) *Repository_ListRules_Call {
	return &Repository_ListRules_Call{Call: _e.mock.On("ListRules", ctx, limit, offset)}
}

func (_c *Repository_ListRules_Call) Run(run func(ctx context.Context, limit int, offset int)) *Repository_ListRules_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 int
		if args[1] != nil {
			arg1 = args[1].(int)
		}
		var arg2 int
		if args[2] != nil {
			arg2 = args[2].(int)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *Repository_ListRules_Call) Return(forwardRules []*models.ForwardRule, n int, err error) *Repository_ListRules_Call {
	_c.Call.Return(forwardRules, n, err)
	return _c
}

func (_c *Repository_ListRules_Call) RunAndReturn(run func(ctx context.Context, limit int, offset int) ([]*models.ForwardRule, int, error)) *Repository_ListRules_Call {
	_c.Call.Return(run)
	return _c
}

// ListRulesByInbox provides a mock function for the type Repository
func (_mock *Repository) ListRulesByInbox(ctx context.Context, inboxID string, limit int, offset int) ([]*models.ForwardRule, int, error) {
	ret := _mock.Called(ctx, inboxID, limit, offset)

	if len(ret) == 0 {
		panic("no return value specified for ListRulesByInbox")
	}

	var r0 []*models.ForwardRule
	var r1 int
	var r2 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, int, int) ([]*models.ForwardRule, int, error)); ok {
		return returnFunc(ctx, inboxID, limit, offset)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, int, int) []*models.ForwardRule); ok {
		r0 = returnFunc(ctx, inboxID, limit, offset)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*models.ForwardRule)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string, int, int) int); ok {
		r1 = returnFunc(ctx, inboxID, limit, offset)
	} else {
		r1 = ret.Get(1).(int)
	}
	if returnFunc, ok := ret.Get(2).(func(context.Context, string, int, int) error); ok {
		r2 = returnFunc(ctx, inboxID, limit, offset)
	} else {
		r2 = ret.Error(2)
	}
	return r0, r1, r2
}

// Repository_ListRulesByInbox_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListRulesByInbox'
type Repository_ListRulesByInbox_Call struct {
	*mock.Call
}

// ListRulesByInbox is a helper method to define mock.On call
//   - ctx context.Context
//   - inboxID string
//   - limit int
//   - offset int
func (_e *Repository_Expecter) ListRulesByInbox(ctx interface{}, inboxID interface{}, limit interface{}, offset interface{}) *Repository_ListRulesByInbox_Call {
	return &Repository_ListRulesByInbox_Call{Call: _e.mock.On("ListRulesByInbox", ctx, inboxID, limit, offset)}
}

func (_c *Repository_ListRulesByInbox_Call) Run(run func(ctx context.Context, inboxID string, limit int, offset int)) *Repository_ListRulesByInbox_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 int
		if args[2] != nil {
			arg2 = args[2].(int)
		}
		var arg3 int
		if args[3] != nil {
			arg3 = args[3].(int)
		}
		run(
			arg0,
			arg1,
			arg2,
			arg3,
		)
	})
	return _c
}

func (_c *Repository_ListRulesByInbox_Call) Return(forwardRules []*models.ForwardRule, n int, err error) *Repository_ListRulesByInbox_Call {
	_c.Call.Return(forwardRules, n, err)
	return _c
}

func (_c *Repository_ListRulesByInbox_Call) RunAndReturn(run func(ctx context.Context, inboxID string, limit int, offset int) ([]*models.ForwardRule, int, error)) *Repository_ListRulesByInbox_Call {
	_c.Call.Return(run)
	return _c
}

// ListTokensByUser provides a mock function for the type Repository
func (_mock *Repository) ListTokensByUser(ctx context.Context, userID string, limit int, offset int) ([]*models.Token, int, error) {
	ret := _mock.Called(ctx, userID, limit, offset)

	if len(ret) == 0 {
		panic("no return value specified for ListTokensByUser")
	}

	var r0 []*models.Token
	var r1 int
	var r2 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, int, int) ([]*models.Token, int, error)); ok {
		return returnFunc(ctx, userID, limit, offset)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, int, int) []*models.Token); ok {
		r0 = returnFunc(ctx, userID, limit, offset)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*models.Token)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string, int, int) int); ok {
		r1 = returnFunc(ctx, userID, limit, offset)
	} else {
		r1 = ret.Get(1).(int)
	}
	if returnFunc, ok := ret.Get(2).(func(context.Context, string, int, int) error); ok {
		r2 = returnFunc(ctx, userID, limit, offset)
	} else {
		r2 = ret.Error(2)
	}
	return r0, r1, r2
}

// Repository_ListTokensByUser_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListTokensByUser'
type Repository_ListTokensByUser_Call struct {
	*mock.Call
}

// ListTokensByUser is a helper method to define mock.On call
//   - ctx context.Context
//   - userID string
//   - limit int
//   - offset int
func (_e *Repository_Expecter) ListTokensByUser(ctx interface{}, userID interface{}, limit interface{}, offset interface{}) *Repository_ListTokensByUser_Call {
	return &Repository_ListTokensByUser_Call{Call: _e.mock.On("ListTokensByUser", ctx, userID, limit, offset)}
}

func (_c *Repository_ListTokensByUser_Call) Run(run func(ctx context.Context, userID string, limit int, offset int)) *Repository_ListTokensByUser_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 int
		if args[2] != nil {
			arg2 = args[2].(int)
		}
		var arg3 int
		if args[3] != nil {
			arg3 = args[3].(int)
		}
		run(
			arg0,
			arg1,
			arg2,
			arg3,
		)
	})
	return _c
}

func (_c *Repository_ListTokensByUser_Call) Return(tokens []*models.Token, n int, err error) *Repository_ListTokensByUser_Call {
	_c.Call.Return(tokens, n, err)
	return _c
}

func (_c *Repository_ListTokensByUser_Call) RunAndReturn(run func(ctx context.Context, userID string, limit int, offset int) ([]*models.Token, int, error)) *Repository_ListTokensByUser_Call {
	_c.Call.Return(run)
	return _c
}

// ListUsers provides a mock function for the type Repository
func (_mock *Repository) ListUsers(ctx context.Context, limit int, offset int) ([]*models.User, int, error) {
	ret := _mock.Called(ctx, limit, offset)

	if len(ret) == 0 {
		panic("no return value specified for ListUsers")
	}

	var r0 []*models.User
	var r1 int
	var r2 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, int, int) ([]*models.User, int, error)); ok {
		return returnFunc(ctx, limit, offset)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, int, int) []*models.User); ok {
		r0 = returnFunc(ctx, limit, offset)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*models.User)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, int, int) int); ok {
		r1 = returnFunc(ctx, limit, offset)
	} else {
		r1 = ret.Get(1).(int)
	}
	if returnFunc, ok := ret.Get(2).(func(context.Context, int, int) error); ok {
		r2 = returnFunc(ctx, limit, offset)
	} else {
		r2 = ret.Error(2)
	}
	return r0, r1, r2
}

// Repository_ListUsers_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListUsers'
type Repository_ListUsers_Call struct {
	*mock.Call
}

// ListUsers is a helper method to define mock.On call
//   - ctx context.Context
//   - limit int
//   - offset int
func (_e *Repository_Expecter) ListUsers(ctx interface{}, limit interface{}, offset interface{}) *Repository_ListUsers_Call {
	return &Repository_ListUsers_Call{Call: _e.mock.On("ListUsers", ctx, limit, offset)}
}

func (_c *Repository_ListUsers_Call) Run(run func(ctx context.Context, limit int, offset int)) *Repository_ListUsers_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 int
		if args[1] != nil {
			arg1 = args[1].(int)
		}
		var arg2 int
		if args[2] != nil {
			arg2 = args[2].(int)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *Repository_ListUsers_Call) Return(users []*models.User, n int, err error) *Repository_ListUsers_Call {
	_c.Call.Return(users, n, err)
	return _c
}

func (_c *Repository_ListUsers_Call) RunAndReturn(run func(ctx context.Context, limit int, offset int) ([]*models.User, int, error)) *Repository_ListUsers_Call {
	_c.Call.Return(run)
	return _c
}

// ProjectAddUser provides a mock function for the type Repository
func (_mock *Repository) ProjectAddUser(ctx context.Context, projectUser *models.ProjectUser) error {
	ret := _mock.Called(ctx, projectUser)

	if len(ret) == 0 {
		panic("no return value specified for ProjectAddUser")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *models.ProjectUser) error); ok {
		r0 = returnFunc(ctx, projectUser)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// Repository_ProjectAddUser_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ProjectAddUser'
type Repository_ProjectAddUser_Call struct {
	*mock.Call
}

// ProjectAddUser is a helper method to define mock.On call
//   - ctx context.Context
//   - projectUser *models.ProjectUser
func (_e *Repository_Expecter) ProjectAddUser(ctx interface{}, projectUser interface{}) *Repository_ProjectAddUser_Call {
	return &Repository_ProjectAddUser_Call{Call: _e.mock.On("ProjectAddUser", ctx, projectUser)}
}

func (_c *Repository_ProjectAddUser_Call) Run(run func(ctx context.Context, projectUser *models.ProjectUser)) *Repository_ProjectAddUser_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *models.ProjectUser
		if args[1] != nil {
			arg1 = args[1].(*models.ProjectUser)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *Repository_ProjectAddUser_Call) Return(err error) *Repository_ProjectAddUser_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *Repository_ProjectAddUser_Call) RunAndReturn(run func(ctx context.Context, projectUser *models.ProjectUser) error) *Repository_ProjectAddUser_Call {
	_c.Call.Return(run)
	return _c
}

// ProjectRemoveUser provides a mock function for the type Repository
func (_mock *Repository) ProjectRemoveUser(ctx context.Context, projectID string, userID string) error {
	ret := _mock.Called(ctx, projectID, userID)

	if len(ret) == 0 {
		panic("no return value specified for ProjectRemoveUser")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, string) error); ok {
		r0 = returnFunc(ctx, projectID, userID)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// Repository_ProjectRemoveUser_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ProjectRemoveUser'
type Repository_ProjectRemoveUser_Call struct {
	*mock.Call
}

// ProjectRemoveUser is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID string
//   - userID string
func (_e *Repository_Expecter) ProjectRemoveUser(ctx interface{}, projectID interface{}, userID interface{}) *Repository_ProjectRemoveUser_Call {
	return &Repository_ProjectRemoveUser_Call{Call: _e.mock.On("ProjectRemoveUser", ctx, projectID, userID)}
}

func (_c *Repository_ProjectRemoveUser_Call) Run(run func(ctx context.Context, projectID string, userID string)) *Repository_ProjectRemoveUser_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 string
		if args[2] != nil {
			arg2 = args[2].(string)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *Repository_ProjectRemoveUser_Call) Return(err error) *Repository_ProjectRemoveUser_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *Repository_ProjectRemoveUser_Call) RunAndReturn(run func(ctx context.Context, projectID string, userID string) error) *Repository_ProjectRemoveUser_Call {
	_c.Call.Return(run)
	return _c
}

// PruneExpiredTokens provides a mock function for the type Repository
func (_mock *Repository) PruneExpiredTokens(ctx context.Context) (int64, error) {
	ret := _mock.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for PruneExpiredTokens")
	}

	var r0 int64
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) (int64, error)); ok {
		return returnFunc(ctx)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context) int64); ok {
		r0 = returnFunc(ctx)
	} else {
		r0 = ret.Get(0).(int64)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = returnFunc(ctx)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Repository_PruneExpiredTokens_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PruneExpiredTokens'
type Repository_PruneExpiredTokens_Call struct {
	*mock.Call
}

// PruneExpiredTokens is a helper method to define mock.On call
//   - ctx context.Context
func (_e *Repository_Expecter) PruneExpiredTokens(ctx interface{}) *Repository_PruneExpiredTokens_Call {
	return &Repository_PruneExpiredTokens_Call{Call: _e.mock.On("PruneExpiredTokens", ctx)}
}

func (_c *Repository_PruneExpiredTokens_Call) Run(run func(ctx context.Context)) *Repository_PruneExpiredTokens_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *Repository_PruneExpiredTokens_Call) Return(n int64, err error) *Repository_PruneExpiredTokens_Call {
	_c.Call.Return(n, err)
	return _c
}

func (_c *Repository_PruneExpiredTokens_Call) RunAndReturn(run func(ctx context.Context) (int64, error)) *Repository_PruneExpiredTokens_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateInbox provides a mock function for the type Repository
func (_mock *Repository) UpdateInbox(ctx context.Context, inbox *models.Inbox) error {
	ret := _mock.Called(ctx, inbox)

	if len(ret) == 0 {
		panic("no return value specified for UpdateInbox")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *models.Inbox) error); ok {
		r0 = returnFunc(ctx, inbox)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// Repository_UpdateInbox_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateInbox'
type Repository_UpdateInbox_Call struct {
	*mock.Call
}

// UpdateInbox is a helper method to define mock.On call
//   - ctx context.Context
//   - inbox *models.Inbox
func (_e *Repository_Expecter) UpdateInbox(ctx interface{}, inbox interface{}) *Repository_UpdateInbox_Call {
	return &Repository_UpdateInbox_Call{Call: _e.mock.On("UpdateInbox", ctx, inbox)}
}

func (_c *Repository_UpdateInbox_Call) Run(run func(ctx context.Context, inbox *models.Inbox)) *Repository_UpdateInbox_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *models.Inbox
		if args[1] != nil {
			arg1 = args[1].(*models.Inbox)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *Repository_UpdateInbox_Call) Return(err error) *Repository_UpdateInbox_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *Repository_UpdateInbox_Call) RunAndReturn(run func(ctx context.Context, inbox *models.Inbox) error) *Repository_UpdateInbox_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateMessageDeletedStatus provides a mock function for the type Repository
func (_mock *Repository) UpdateMessageDeletedStatus(ctx context.Context, messageID string, isDeleted bool) error {
	ret := _mock.Called(ctx, messageID, isDeleted)

	if len(ret) == 0 {
		panic("no return value specified for UpdateMessageDeletedStatus")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, bool) error); ok {
		r0 = returnFunc(ctx, messageID, isDeleted)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// Repository_UpdateMessageDeletedStatus_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateMessageDeletedStatus'
type Repository_UpdateMessageDeletedStatus_Call struct {
	*mock.Call
}

// UpdateMessageDeletedStatus is a helper method to define mock.On call
//   - ctx context.Context
//   - messageID string
//   - isDeleted bool
func (_e *Repository_Expecter) UpdateMessageDeletedStatus(ctx interface{}, messageID interface{}, isDeleted interface{}) *Repository_UpdateMessageDeletedStatus_Call {
	return &Repository_UpdateMessageDeletedStatus_Call{Call: _e.mock.On("UpdateMessageDeletedStatus", ctx, messageID, isDeleted)}
}

func (_c *Repository_UpdateMessageDeletedStatus_Call) Run(run func(ctx context.Context, messageID string, isDeleted bool)) *Repository_UpdateMessageDeletedStatus_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 bool
		if args[2] != nil {
			arg2 = args[2].(bool)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *Repository_UpdateMessageDeletedStatus_Call) Return(err error) *Repository_UpdateMessageDeletedStatus_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *Repository_UpdateMessageDeletedStatus_Call) RunAndReturn(run func(ctx context.Context, messageID string, isDeleted bool) error) *Repository_UpdateMessageDeletedStatus_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateMessageReadStatus provides a mock function for the type Repository
func (_mock *Repository) UpdateMessageReadStatus(ctx context.Context, messageID string, isRead bool) error {
	ret := _mock.Called(ctx, messageID, isRead)

	if len(ret) == 0 {
		panic("no return value specified for UpdateMessageReadStatus")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, bool) error); ok {
		r0 = returnFunc(ctx, messageID, isRead)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// Repository_UpdateMessageReadStatus_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateMessageReadStatus'
type Repository_UpdateMessageReadStatus_Call struct {
	*mock.Call
}

// UpdateMessageReadStatus is a helper method to define mock.On call
//   - ctx context.Context
//   - messageID string
//   - isRead bool
func (_e *Repository_Expecter) UpdateMessageReadStatus(ctx interface{}, messageID interface{}, isRead interface{}) *Repository_UpdateMessageReadStatus_Call {
	return &Repository_UpdateMessageReadStatus_Call{Call: _e.mock.On("UpdateMessageReadStatus", ctx, messageID, isRead)}
}

func (_c *Repository_UpdateMessageReadStatus_Call) Run(run func(ctx context.Context, messageID string, isRead bool)) *Repository_UpdateMessageReadStatus_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 bool
		if args[2] != nil {
			arg2 = args[2].(bool)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *Repository_UpdateMessageReadStatus_Call) Return(err error) *Repository_UpdateMessageReadStatus_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *Repository_UpdateMessageReadStatus_Call) RunAndReturn(run func(ctx context.Context, messageID string, isRead bool) error) *Repository_UpdateMessageReadStatus_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateProject provides a mock function for the type Repository
func (_mock *Repository) UpdateProject(ctx context.Context, project *models.Project) error {
	ret := _mock.Called(ctx, project)

	if len(ret) == 0 {
		panic("no return value specified for UpdateProject")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *models.Project) error); ok {
		r0 = returnFunc(ctx, project)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// Repository_UpdateProject_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateProject'
type Repository_UpdateProject_Call struct {
	*mock.Call
}

// UpdateProject is a helper method to define mock.On call
//   - ctx context.Context
//   - project *models.Project
func (_e *Repository_Expecter) UpdateProject(ctx interface{}, project interface{}) *Repository_UpdateProject_Call {
	return &Repository_UpdateProject_Call{Call: _e.mock.On("UpdateProject", ctx, project)}
}

func (_c *Repository_UpdateProject_Call) Run(run func(ctx context.Context, project *models.Project)) *Repository_UpdateProject_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *models.Project
		if args[1] != nil {
			arg1 = args[1].(*models.Project)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *Repository_UpdateProject_Call) Return(err error) *Repository_UpdateProject_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *Repository_UpdateProject_Call) RunAndReturn(run func(ctx context.Context, project *models.Project) error) *Repository_UpdateProject_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateRule provides a mock function for the type Repository
func (_mock *Repository) UpdateRule(ctx context.Context, rule *models.ForwardRule) error {
	ret := _mock.Called(ctx, rule)

	if len(ret) == 0 {
		panic("no return value specified for UpdateRule")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *models.ForwardRule) error); ok {
		r0 = returnFunc(ctx, rule)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// Repository_UpdateRule_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateRule'
type Repository_UpdateRule_Call struct {
	*mock.Call
}

// UpdateRule is a helper method to define mock.On call
//   - ctx context.Context
//   - rule *models.ForwardRule
func (_e *Repository_Expecter) UpdateRule(ctx interface{}, rule interface{}) *Repository_UpdateRule_Call {
	return &Repository_UpdateRule_Call{Call: _e.mock.On("UpdateRule", ctx, rule)}
}

func (_c *Repository_UpdateRule_Call) Run(run func(ctx context.Context, rule *models.ForwardRule)) *Repository_UpdateRule_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *models.ForwardRule
		if args[1] != nil {
			arg1 = args[1].(*models.ForwardRule)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *Repository_UpdateRule_Call) Return(err error) *Repository_UpdateRule_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *Repository_UpdateRule_Call) RunAndReturn(run func(ctx context.Context, rule *models.ForwardRule) error) *Repository_UpdateRule_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateTokenLastUsed provides a mock function for the type Repository
func (_mock *Repository) UpdateTokenLastUsed(ctx context.Context, tokenID string) error {
	ret := _mock.Called(ctx, tokenID)

	if len(ret) == 0 {
		panic("no return value specified for UpdateTokenLastUsed")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) error); ok {
		r0 = returnFunc(ctx, tokenID)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// Repository_UpdateTokenLastUsed_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateTokenLastUsed'
type Repository_UpdateTokenLastUsed_Call struct {
	*mock.Call
}

// UpdateTokenLastUsed is a helper method to define mock.On call
//   - ctx context.Context
//   - tokenID string
func (_e *Repository_Expecter) UpdateTokenLastUsed(ctx interface{}, tokenID interface{}) *Repository_UpdateTokenLastUsed_Call {
	return &Repository_UpdateTokenLastUsed_Call{Call: _e.mock.On("UpdateTokenLastUsed", ctx, tokenID)}
}

func (_c *Repository_UpdateTokenLastUsed_Call) Run(run func(ctx context.Context, tokenID string)) *Repository_UpdateTokenLastUsed_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *Repository_UpdateTokenLastUsed_Call) Return(err error) *Repository_UpdateTokenLastUsed_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *Repository_UpdateTokenLastUsed_Call) RunAndReturn(run func(ctx context.Context, tokenID string) error) *Repository_UpdateTokenLastUsed_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateUser provides a mock function for the type Repository
func (_mock *Repository) UpdateUser(ctx context.Context, user *models.User) error {
	ret := _mock.Called(ctx, user)

	if len(ret) == 0 {
		panic("no return value specified for UpdateUser")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *models.User) error); ok {
		r0 = returnFunc(ctx, user)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// Repository_UpdateUser_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateUser'
type Repository_UpdateUser_Call struct {
	*mock.Call
}

// UpdateUser is a helper method to define mock.On call
//   - ctx context.Context
//   - user *models.User
func (_e *Repository_Expecter) UpdateUser(ctx interface{}, user interface{}) *Repository_UpdateUser_Call {
	return &Repository_UpdateUser_Call{Call: _e.mock.On("UpdateUser", ctx, user)}
}

func (_c *Repository_UpdateUser_Call) Run(run func(ctx context.Context, user *models.User)) *Repository_UpdateUser_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *models.User
		if args[1] != nil {
			arg1 = args[1].(*models.User)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *Repository_UpdateUser_Call) Return(err error) *Repository_UpdateUser_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *Repository_UpdateUser_Call) RunAndReturn(run func(ctx context.Context, user *models.User) error) *Repository_UpdateUser_Call {
	_c.Call.Return(run)
	return _c
}
